
<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>电子礼簿系统 - 精修版</title>
    <script src="./static/tailwindcss.js"></script>
    <script src="./static/xlsx.full.min.js"></script>
    <script src="./static/crypto-js.min.js"></script>
    <link href="./static/mermaid.min.css" rel="stylesheet" />
    <link href="./static/remixicon.css" rel="stylesheet" />
    <script src="./static/gridjs.umd.js"></script>
    <script src="./static/pdf-lib.min.js"></script>
    <script src="./static/fontkit.umd.min.js"></script>
    <script src="./static/GiftListPDFGenerator.js"></script>
    <link rel="preload" href="./static/bg.jpg" as="image" type="image/jpeg" />
    <link rel="preload" href="./static/cover1.jpg" as="image" type="image/jpeg" />
    <link rel="preload" href="./static/cover2.jpg" as="image" type="image/jpeg" />
    <style>
            :root,
      .theme-festive {
        --primary-color: #c00;
        --primary-color-hover: #a00;
        --primary-text-color: #c00;
        --primary-bg-light: #fff2f2;
        --primary-border-color: #ffaaaa;
        --primary-ring-color: #ef4444;
        --header-text-color: #b91c1c;
        --button-bg-color: #dc2626;
        --button-bg-hover: #b91c1c;
        --button-border-color: #dc2626;
        --button-text-color: #dc2626;
        --link-hover-bg: #fee2e2;
        --total-text-color: #ef4444;

        /* 默认自定义变量 */
        --name-font-size: var(--custom-name-size, 25px);
        --name-color: var(--custom-name-color, #333);
        --name-font-family: var(--custom-name-font, "KaiTi", "楷体", serif);
        --type-font-size: var(--custom-type-size, 22px);
        --type-color: var(--custom-type-color, #c00);
        --type-font-family: var(--custom-type-font, "Source Han Serif CN Heavy", serif);

        --amount-chinese-font-size: var(--custom-amount-chinese-size, 25px);
        --amount-chinese-color: var(--custom-amount-chinese-color, #333);
        --amount-chinese-font-family: var(--custom-amount-chinese-font, "KaiTi", "楷体", serif);

        --cover-text-font-size: var(--custom-cover-text-size, 30px);
        --cover-text-color: var(--custom-cover-text-color, #f5d4ab);
        --cover-text-font-family: var(--custom-cover-text-font, "KaiTi", "楷体", serif);

        --page-info-color: var(--custom-page-info-color, var(--primary-color));
        --page-info-font-family: var(--custom-page-info-font, inherit);
      }

      .theme-solemn {
        --primary-color: #374151;
        --primary-color-hover: #1f2937;
        --primary-text-color: #111827;
        --primary-bg-light: #f3f4f6;
        --primary-border-color: #d1d5db;
        --primary-ring-color: #4b5563;
        --header-text-color: #1f2937;
        --button-bg-color: #4b5563;
        --button-bg-hover: #374151;
        --button-border-color: #4b5563;
        --button-text-color: #4b5563;
        --link-hover-bg: #e5e7eb;
        --total-text-color: #374151;

        --type-color: var(--custom-type-color, #374151);
      }

      /* ==================== 基础样式 ==================== */
      body {
        font-family: "Inter", "Microsoft YaHei", sans-serif;
      }

      /* ==================== 礼簿样式 (屏幕显示) ==================== */
      .gift-book-frame {
        border: 4px solid var(--primary-color);
        padding: 22px;
        border-radius: 10px;
        background-color: var(--primary-bg-light);
        position: relative;
        display: grid;
        grid-template-rows: auto 1fr;
        height: 100%;
        cursor: default;
        min-height: 450px;
      }

      #gift-book-content {
        display: grid;
        grid-template-rows: 3fr 1fr 3fr;
        border-top: 2px solid var(--primary-border-color);
        min-height: 0;
      }

      .print-book-content {
        display: flex;
        flex-direction: column;
        border-top: 2px solid var(--primary-border-color);
        flex: 1;
      }

      .print-book-content > .gift-book-row:first-child,
      .print-book-content > .gift-book-row:last-child {
        flex: 1;
        min-height: 0;
      }

      .gift-book-row {
        width: 100%;
        display: grid;
        grid-template-columns: repeat(var(--gift-grid-columns, 12), minmax(0, 1fr));
      }
      .gift-book-row:nth-child(1),
      .gift-book-row:nth-child(3) {
        min-height: 33.3%;
      }

      .gift-book-row > .book-cell {
        min-width: 0;
        position: relative;
        line-height: 1.2;
      }

      .book-cell {
        border-right: 2px solid var(--primary-border-color);
        border-bottom: 2px solid var(--primary-border-color);
        display: grid;
        place-items: center;
        writing-mode: vertical-lr;
        text-orientation: mixed;
        font-weight: bold;
        font-size: clamp(16px, 1.6vw, 25px);
        letter-spacing: 7px;
        font-family: "KaiTi", "楷体", serif;
        padding: 10px 0;
        overflow: hidden;
        text-align: center;
      }

      .book-cell:first-child {
        border-left: 2px solid var(--primary-border-color);
      }

      .book-cell:hover {
        background-color: var(--link-hover-bg);
      }

      .name-cell .name {
        color: var(--name-color);
        padding: 15px 0;
        cursor: pointer;
        text-align: center;
        white-space: nowrap;
        min-height: 8em;
        font-size: var(--name-font-size);
        font-family: var(--name-font-family);
      }

      .type-cell {
        color: var(--type-color);
        font-size: var(--type-font-size);
        padding: 10px 4px;
        font-family: var(--type-font-family);
        font-weight: bold;
      }

      .amount-cell {
        color: #333;
        cursor: pointer;
        grid-template-columns: 1fr auto;
        column-gap: clamp(8px, 1.5vw, 18px);
        justify-content: center;
      }

      .amount-chinese {
        letter-spacing: 1.5px;
        text-align: center;
        padding: 15px 0;
        flex: 1;
        overflow: hidden;
        font-size: var(--amount-chinese-font-size);
        color: var(--amount-chinese-color);
        font-family: var(--amount-chinese-font-family);
      }
      .amount-numeric {
        color: #555;
        letter-spacing: 1px;
        writing-mode: horizontal-tb;
        line-height: 3;
        font-size: clamp(10px, 1.3vw, 14px);
      }

      .mark {
        font-size: clamp(10px, 1.3vw, 14px);
        letter-spacing: 1px;
        color: var(--primary-color);
        white-space: nowrap;
        line-height: 1.2;
        height: 2.5em;
        display: flex;
        flex-direction: column;
        justify-content: center;
        position: absolute;
        bottom: 1vw;
        writing-mode: lr;
      }

      /* ==================== 主题组件 ==================== */
      .themed-edit-area {
        background-color: var(--primary-bg-light);
        border: 1px solid var(--primary-border-color);
        padding: 1rem;
        border-radius: 0.5rem;
        width: 100%;
      }

      input[type="checkbox"] {
        accent-color: var(--button-bg-color);
      }

      input[type="number"]::-webkit-inner-spin-button,
      input[type="number"]::-webkit-outer-spin-button {
        -webkit-appearance: none;
        margin: 0;
      }
      input[type="number"] {
        -moz-appearance: textfield;
      }

      .themed-header {
        color: var(--header-text-color);
      }
      .themed-button-primary {
        background-color: var(--button-bg-color);
        color: white;
      }
      .themed-button-primary:hover {
        background-color: var(--button-bg-hover);
      }
      .themed-button-secondary {
        border-color: var(--button-border-color);
        color: var(--button-text-color);
      }
      .themed-button-secondary:hover {
        background-color: var(--link-hover-bg);
      }
      .themed-ring:focus {
        --tw-ring-color: var(--primary-ring-color) !important;
      }
      .themed-text-radio {
        color: var(--button-text-color);
      }
      .themed-peer-checked {
        --tw-bg-opacity: 1;
        background-color: var(--button-bg-color);
      }
      .themed-text {
        color: var(--total-text-color);
      }
      .themed-link-hover:hover {
        background-color: var(--link-hover-bg);
      }
      .themed-dropdown-text {
        color: var(--primary-text-color);
        overflow: hidden;
        white-space: nowrap;
        text-overflow: ellipsis;
      }
      .themed-dropdown-text:hover {
        color: var(--primary-color-hover);
      }
      .peer:checked ~ .toggle-bg {
        background-color: var(--button-bg-color);
      }

      .remark-preset-btn.themed-button-primary {
        background-color: var(--primary-bg-light);
        color: var(--primary-text-color);
      }

      /* ==================== 弹窗和打印容器 ==================== */
      #modal {
        display: flex;
        flex-direction: column;
        max-height: 90vh;
        margin: 0 10px;
        position: relative;
      }

      #modal-content {
        flex: 1;
        overflow-y: auto;
        padding-right: 0.5rem;
      }
      #modal-close-btn {
        position: absolute;
        top: 0.75rem;
        right: 0.75rem;
        color: #9ca3af;
        transition: color 0.2s ease-in-out;
      }
      #modal-close-btn:hover,
      #modal-close-btn:focus {
        color: #4b5563;
      }
      #modal-close-btn:focus-visible {
        outline: 2px solid var(--primary-ring-color);
        outline-offset: 2px;
      }
      body.printing #app-container {
        display: none;
      }
      #modal.modal-large {
        max-width: 1200px;
        width: 95vw;
      }
      td.gridjs-td,
      th.gridjs-th {
        padding: 6px;
      }
      #print-view {
        visibility: hidden;
      }
      /* ==================== 缩放样式 ==================== */
      .amount-chinese.scale,
      .name.scale {
        font-size: 14pt;
        letter-spacing: -2px;
        padding: 5px 0;
      }
      .amount-numeric.scale {
        letter-spacing: 0.5px;
        writing-mode: vertical-rl;
      }
      /* ==================== 响应式 ==================== */
      @media (max-width: 700px) {
        .amount-numeric,
        .mark {
          position: relative;
          writing-mode: vertical-rl;
        }
        .gridjs-wrapper {
          overflow-x: auto;
          height: 30vh !important;
        }
      }

      /* ==================== 打印样式 ==================== */
      @media print {
        :root {
          /* 打印物理尺寸设置 */
          --print-page-width: 210mm;
          --print-page-height: 297mm;
          --print-content-height: 188mm;
          --print-padding-top: 9mm;
          --print-padding-side: 9.5mm;
          --print-footer-bottom: 12px;
          --print-theme-color: var(--custom-print-theme-color, #ec403c);
          --print-base-color: var(--custom-print-base-color, #1f2937);
          --print-base-font: var(--custom-print-base-font, "KaiTi", "楷体", serif);
        }

        /* 页面重置 */
        @page {
          size: var(--print-page-height) var(--print-page-width);
          margin: 0;
        }

        /* 隐藏屏幕元素，显示打印视图 */
        body * {
          visibility: hidden;
        }
        #print-view,
        #print-view * {
          visibility: visible;
        }

        #print-view {
          position: absolute;
          left: 0;
          top: 0;
          width: 100%;
          height: 100%;
        }

        /* --- 容器与背景 --- */

        /* 外框：统一使用主题色 */
        .gift-book-frame {
          background-color: transparent;
          border-color: var(--print-theme-color) !important;
        }

        .print-page {
          page-break-after: always;
          width: 100%;
          height: 100%;
          padding: var(--print-padding-top) var(--print-padding-side) 0;
          box-sizing: border-box;
          display: flex;
          flex-direction: column;
          background: var(--custom-bg-image, url("./static/bg.jpg")) center/contain no-repeat, var(--primary-bg-light);
          overflow: hidden;
          position: relative;
          font-family: var(--print-base-font);
          color: var(--print-base-color);
          -webkit-print-color-adjust: exact;
          print-color-adjust: exact;
        }

        /* --- 封面页 --- */
        .print-cover-page {
          padding: 0;
          background: none;
          justify-content: center;
          align-items: center;
        }

        .print-cover {
          display: flex;
          flex-direction: column;
          justify-content: flex-end;
          align-items: center;
          text-align: center;
          width: 100%;
          height: 100%;
          background: var(--custom-cover-image, url("./static/cover1.jpg")) center/contain no-repeat, var(--primary-bg-light);
          /* 封面独立变量 */
          color: var(--cover-text-color);
          font-family: var(--cover-text-font-family);
          padding-bottom: 20mm;
          box-sizing: border-box;
          position: relative;
        }

        .print-cover p {
          font-size: var(--cover-text-font-size);
          letter-spacing: 4px;
        }

        /* --- 礼簿表格核心样式 --- */

        .book-cell {
          font-size: 18pt !important;
          border-color: var(--print-theme-color) !important; /* 边框跟随主题色 */
          font-family: var(--print-base-font) !important; /* 字体跟随基础设置 */
          color: var(--print-base-color); /* 颜色跟随基础设置 */
        }

        .type-cell {
          color: var(--custom-type-color, var(--type-color)) !important;
          font-family: var(--custom-type-font, var(--type-font-family)) !important;
          font-size: var(--custom-type-size, 18pt) !important;
          font-weight: bold;
        }

        .name-cell .name {
          color: var(--custom-name-color, var(--name-color)) !important;
          font-family: var(--custom-name-font, var(--name-font-family)) !important;
          font-size: var(--custom-name-size, 18pt) !important;
          padding: 0;
        }
        .name-cell:hover {
          background-color: transparent;
        }

        .amount-chinese {
          color: var(--custom-amount-chinese-color, var(--amount-chinese-color)) !important;
          font-family: var(--custom-amount-chinese-font, var(--amount-chinese-font-family)) !important;
          font-size: var(--custom-amount-chinese-size, 18pt) !important;
        }

        .amount-numeric {
          display: block;
          color: var(--print-base-color, #333) !important;
        }

        .print-book-content {
          border-top-color: var(--print-theme-color) !important;
          height: var(--print-content-height) !important;
          flex: none !important;
          overflow: hidden !important;
        }

        /* --- 页头与页脚 --- */

        .print-header {
          text-align: center;
          margin: 35px 0 0;
          color: var(--print-theme-color);
          font-family: var(--print-base-font);
          font-weight: bold;
          font-size: 38px;
        }

        .print-footer {
          flex: 1;
          display: flex;
          justify-content: space-between;
          align-items: flex-end;
          font-size: 17px;
          padding: 0 0 var(--print-footer-bottom);
          color: var(--print-base-color);
          font-family: var(--print-base-font);
          margin-top: auto;
        }

        .print-footer p {
          margin: 3px 0;
          flex: 1;
        }
        .print-footer-totals {
          flex: 1;
          text-align: right;
        }
        .print-footer .total-amount-print {
          font-weight: bold;
        }
        .print-footer-totals .total-amount-print:not(:last-child) {
          margin-right: 25px;
        }
        .print-page-number {
          text-align: center;
        }

        /* --- 附录表格样式 --- */

        .print-appendix-table {
          width: 90%;
          margin: 20px auto 0 auto;
          text-align: center;
          box-sizing: border-box;
          line-height: 4.5em;
        }

        .print-appendix-table th,
        .print-appendix-table td {
          border: 2px solid var(--print-theme-color);
          padding: 8px;
          word-break: break-word;
          font-family: var(--print-base-font);
          font-weight: bold;
          letter-spacing: 2px;
        }

        #print-view .print-appendix-table th {
          color: var(--print-theme-color);
          text-align: center !important;
        }

        /* 附录内容：基础字色 */
        #print-view .print-appendix-table td {
          color: var(--print-base-color);
        }

        .print-appendix-table th:nth-child(3) {
          width: 60%;
        }

        /* 兼容性与杂项 */
        .theme-solemn #print-view {
          filter: grayscale(100%);
        }
        .mark {
          display: none;
        }
      }
    </style>
  </head>

  <body class="bg-gray-100 flex items-center justify-center min-h-screen theme-festive">
    <div id="app-container" class="w-full max-w-7xl mx-auto p-4">
      <!-- 设置界面 -->
      <div id="setup-screen" class="bg-white p-8 rounded-lg shadow-xl max-w-2xl mx-auto hidden">
        <h1 class="text-3xl font-bold text-center themed-header mb-6">电子礼簿系统</h1>
        <div id="select-event-section" class="mb-8 hidden">
          <h2 class="text-xl font-semibold mb-4 border-b pb-2">选择已有事项</h2>
          <div class="flex items-center space-x-4">
            <select id="event-selector" class="flex-1 p-3 border rounded-lg focus:ring-2 themed-ring">
              <option value="">请选择一个事项</option>
            </select>
            <button id="unlock-event-btn" class="themed-button-primary px-6 py-3 rounded-lg transition duration-300">进入</button>
          </div>
        </div>
        <div>
          <h2 class="text-xl font-semibold mb-4 border-b pb-2"><span id="or-text"> </span>创建新事项</h2>
          <form id="create-event-form" class="space-y-4">
            <input type="text" id="event-name" placeholder="事项名称 (例如: 张三李四新婚之喜)" required class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" />
 




<!-- 隐藏元素：代码是： style="display: none;"    -->
           <div class="grid grid-cols-1 md:grid-cols-2 gap-4"style="display: none;">
              <div>
                <label class="block text-sm font-medium text-gray-700">开始时间</label>
                <div class="flex gap-2">
                  <input type="date" id="start-date" required class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" />
                  <input type="time" id="start-time" required class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" />
             </div>
             </div>
             <div>
                 <label class="block text-sm font-medium text-gray-700">结束时间</label>  
                 <div class="flex gap-2"> 
                 <input type="date" id="end-date" required class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" /> 
                 <input type="time" id="end-time" required class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" /> 

            </div>
             </div>
             </div>
            <input type="text" id="admin-password" placeholder="设置管理密码 (请牢记)" required class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" />



              </summary>
              <div class="mt-4 p-4 bg-gray-50 rounded-lg border">
                <div>
                  <label for="event-theme" class="block text-sm font-medium text-red-500">喜事与白事界面配色风格选择。</label>
                  <select id="event-theme" class="mt-1 w-full p-3 border rounded-lg focus:ring-2 themed-ring">
                    <option value="theme-festive" selected>喜庆红 (喜事)</option>
                    <option value="theme-solemn">肃穆灰 (白事)</option>
                  </select>
                
                </div>


<!-- 隐藏元素， 代码是：style="display: none;"    -->
<div class="mt-4" style="display: none;">
  <label for="event-voice" class="block text-sm font-medium text-gray-500">语音播报音色</label>
  <div class="flex items-center gap-2 mt-1">
    <select id="event-voice" class="text-sm flex-grow w-full p-3 border rounded-lg focus:ring-2 themed-ring">
      <option value="">默认音色</option>
    </select>
    <button type="button" id="preview-create-voice-btn" class="themed-button-secondary border p-3 rounded-lg whitespace-nowrap text-xl"><i class="ri-volume-up-line"></i> 预览</button>
  </div>
  <p class="text-xs text-gray-500 mt-2">选择一个喜欢的播报声音。</p>

                </div>
                <div class="mt-4">
                  <label class="block text-sm font-medium text-red-500">记账人</label>
                  <input type="text" id="event-recorder" placeholder="记账人 (例如: 喻三，选填)" class="w-full mt-1 p-3 border rounded-lg focus:ring-2 themed-ring" />
                </div>
              </div>
            </details>

            <button type="submit" class="w-full themed-button-primary p-3 rounded-lg transition duration-300 font-bold">创建并进入</button>
          </form>
        </div>
      </div>

      <!-- 主界面 -->
      <div id="main-screen" class="hidden">
        <div class="flex justify-between items-center mb-4">
          <div class="flex items-center gap-4">
            <div class="relative">
              <div id="event-switcher-trigger" class="flex items-center gap-2 cursor-pointer group">
                <h1 id="current-event-title" class="text-2xl font-bold themed-dropdown-text max-sm:text-2xl"></h1>
                <i class="ri-arrow-down-s-line text-2xl themed-dropdown-text"></i>
              </div>
              <div id="event-dropdown" class="absolute top-full left-0 mt-2 w-72 bg-white rounded-md shadow-lg z-10 hidden"></div>
            </div>
          </div>
        </div>
        <div class="grid grid-cols-1 lg:grid-cols-3 gap-6">
          <!-- 左侧录入区 -->
          <div class="lg:col-span-1 bg-white p-6 rounded-lg shadow-lg">
            <h2 class="text-2xl font-bold mb-4 text-center border-b pb-2">礼金录入</h2>
            <form id="add-gift-form" class="space-y-4">
              <input type="text" id="guest-name" placeholder="姓名" required class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" />
              <input type="number" id="gift-amount" placeholder="金额 (元)" required min="0" max="999999999999" step="0.01" class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" />
              <div class="flex flex-wrap items-center gap-x-2 gap-y-2">
                <label class="text-sm font-medium text-gray-700 whitespace-nowrap">收款类型：</label>
                <div class="flex flex-wrap gap-x-3 gap-y-2">
                  <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="payment-type" value="现金" class="themed-text-radio themed-ring" checked /><span>现金</span></label>
                  <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="payment-type" value="微信" class="themed-text-radio themed-ring" /><span>微信</span></label>
                  <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="payment-type" value="支付宝" class="themed-text-radio themed-ring" /><span>支付宝</span></label>
                  <label class="flex items-center space-x-2 cursor-pointer"><input type="radio" name="payment-type" value="其他" class="themed-text-radio themed-ring" /><span>其他</span></label>
                </div>
              </div>
              <textarea id="guest-remark-custom" class="w-full p-3 border rounded-lg focus:ring-2 themed-ring" rows="2" placeholder="备注内容（选填）" data-remark-type="custom"></textarea>
              <div class="flex flex-wrap items-center gap-x-1 gap-y-2">
                <label class="text-sm font-medium text-gray-700 whitespace-nowrap">更多备注：</label>
                <div class="flex flex-wrap gap-2">
                  <button type="button" class="remark-preset-btn px-3 py-1.5 text-xs border rounded-lg themed-ring" data-preset="gift">礼品</button>
                  <button type="button" class="remark-preset-btn px-3 py-1.5 text-xs border rounded-lg themed-ring" data-preset="relation">关系</button>
                  <button type="button" class="remark-preset-btn px-3 py-1.5 text-xs border rounded-lg themed-ring" data-preset="phone">电话</button>
                  <button type="button" class="remark-preset-btn px-3 py-1.5 text-xs border rounded-lg themed-ring" data-preset="address">住址</button>
                </div>
              </div>
              <!-- 用于动态添加“礼品”、“关系”等输入框的容器 -->
              <div id="remark-inputs-container" class="space-y-2"></div>
              <button type="submit" class="w-full themed-button-primary font-bold p-4 rounded-lg transition duration-300 text-lg">确认录入</button>
            </form>
            <div class="mt-6 pt-6 border-t">
              <h3 class="text-xl font-semibold mb-3">功能区</h3>
              <div class="space-y-3">
                <div class="relative">
                  <input type="text" id="search-name" placeholder="按姓名查找..." class="w-full p-3 border rounded-lg focus:ring-2 themed-ring pr-10" />
                  <i id="search-icon" class="ri-search-line text-xl absolute right-3 top-3 text-gray-400 cursor-pointer"></i>
                </div>
                <button id="print-btn" class="w-full themed-button-primary p-3 rounded-lg">打印/另存为PDF</button>
                <button id="export-excel-btn" class="w-full border themed-button-secondary p-3 rounded-lg">导出为 Excel</button>
                <button id="stats-btn" class="w-full themed-button-primary p-3 rounded-lg">查看统计</button>
                <div class="flex items-center justify-between bg-gray-100 p-3 rounded-lg">
                  <span class="font-medium text-gray-700">语音播报</span>
                  <label for="speech-toggle" class="relative inline-flex items-center cursor-pointer">
                    <input type="checkbox" id="speech-toggle" class="sr-only peer" checked />
                    <div
                      class="toggle-bg w-11 h-6 bg-gray-300 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:left-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all"
                    ></div>
                  </label>
                </div>
              </div>
            </div>
          </div>
          <!-- 右侧展示区 -->
          <div class="lg:col-span-2">
            <div id="book-container-wrapper" class="gift-book-frame">
              <div id="book-footer" class="flex justify-between items-center mb-4 flex-wrap gap-y-2">
                <div class="flex items-center flex-wrap gap-x-4">
                  <div><span class="font-bold text-md">本页小计:</span> <span id="page-subtotal" class="text-xl font-bold themed-text">￥0.00</span></div>
                  <div><span class="font-bold text-md">总金额:</span> <span id="total-amount" class="text-xl font-bold themed-text">￥0.00</span></div>
                  <div><span class="font-bold text-md">总人数:</span> <span id="total-givers" class="text-xl font-bold themed-text">0</span></div>
                </div>
                <div class="flex items-center space-x-2 text-lg">
                  <button id="prev-page-btn" class="themed-button-primary p-2 disabled:bg-gray-300 rounded-full w-8 h-8 flex items-center justify-center">
                    <i class="ri-arrow-left-s-line"></i>
                  </button>
                  <div id="page-info" class="font-bold flex items-center">第 1 / 1 页</div>
                  <button id="next-page-btn" class="themed-button-primary p-2 disabled:bg-gray-300 rounded-full w-8 h-8 flex items-center justify-center">
                    <i class="ri-arrow-right-s-line"></i>
                  </button>
                </div>
              </div>
              <div id="gift-book-content"></div>
            </div>
          </div>
        </div>
      </div>
    </div>
    <div class="absolute lg:fixed top-5 right-5 flex gap-3 z-40">
      <button id="support-btn" class="bg-white/80 backdrop-blur rounded-full p-2 shadow-sm hover:shadow-md transition-all group" title="联系/支持作者">
        <i class="ri-heart-3-line text-2xl text-red-500 group-hover:scale-110 transition-transform block"></i>
      </button>

      <button id="fullscreen-btn" class="bg-white/80 backdrop-blur rounded-full p-2 shadow-sm hover:shadow-md transition-all" title="全屏/退出全屏">
        <i id="fullscreen-icon" class="ri-fullscreen-line text-2xl themed-text themed-dropdown-text"></i>
      </button>
    </div>
    <!-- 模态框 -->
    <div id="modal-container" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center hidden z-50">
      <div id="modal" class="bg-white p-6 rounded-lg shadow-xl w-full max-w-md">
        <button id="modal-close-btn" type="button" aria-label="关闭弹窗" class="w-10 h-10 flex items-center justify-center rounded-full hover:bg-gray-100 transition focus:outline-none">
          <i class="ri-close-line text-2xl"></i>
        </button>
        <h3 id="modal-title" class="text-xl font-bold mb-4 text-center"></h3>
        <div id="modal-content"></div>
        <div id="modal-actions" class="mt-6 flex justify-end space-x-3"></div>
      </div>
    </div>

    <script type="module">
      /**
       * 应用配置常量
       * 集中管理所有全局配置参数，便于统一维护和调整
       */
      const CONFIG = {
        /**
         * 每页显示的礼金记录数量
         * 影响：
         * - 主界面礼簿显示
         * - 打印PDF每页容量
         * - 分页导航计算
         */
        ITEMS_PER_PAGE: 12,

        /**
         * 礼簿封面图最大文件大小（2MB）
         * 超过此大小的图片将被拒绝上传
         * 原因：避免 IndexedDB 存储压力和打印性能问题
         */
        MAX_COVER_SIZE: 2 * 1024 * 1024,

        /**
         * 打印分批阈值（1008 条记录 = 84 页）
         * 超过此数量将启用分批打印模式
         * 原因：
         * - 防止浏览器渲染大量 DOM 导致卡死
         * - 避免内存溢出
         * - 提高打印成功率
         * 同时用于 GridJS 表格分页判断
         */
        PRINT_SPLIT_THRESHOLD: 1008,
        APP_NAME: "电子礼簿系统 - 专业版",
        DB_NAME: "GiftRegistryDB",
        DB_VERSION: 1,
        /**
         * 宾客等级系统配置
         * 使用数组存储等级名称，索引即为等级权重（用于排序）
         * 索引越大，等级越高，在打印/导出时排名越靠前
         * 索引范围：0-4
         */
        GUEST_LEVELS: ["普宾", ...Array.from({ length: 100 }, (_, index) => `排序${100 - index}`)],
        PASSWORD_CACHE_DURATION: 5,
      };

      const DEFAULT_PRINT_OPTIONS = Object.freeze({
        printCover: true,
        printEndPage: true,
        printAppendix: true,
        printSummary: true,
        printAbolished: true,
        showCoverTitle: true,
        pdfEngine: "browser",
      });

      /**
       * 工具类 - 提供通用工具方法
       * 集中管理数据格式化、转换等通用功能
       */
      class Utils {
        /**
         * 格式化金额为人民币格式
         * @param {number} amount - 金额数值
         * @returns {string} 格式化后的字符串，如 "￥1,234.56"
         */
        static formatCurrency(amount) {
          return new Intl.NumberFormat("zh-CN", {
            style: "currency",
            currency: "CNY",
          }).format(amount || 0);
        }

        /**
         * 将数字金额转换为中文大写金额
         * @param {number|string} n - 要转换的金额
         * @returns {string} 中文大写金额字符串
         * @example
         */
        static amountToChinese(n) {
          if (typeof n !== "number" && typeof n !== "string") return "";
          n = parseFloat(n);
          if (isNaN(n) || n === null) return "";
          if (n === 0) return "零元整";

          let unit = "京亿万仟佰拾兆万仟佰拾亿仟佰拾万仟佰拾元角分";
          let str = "";
          let s = n.toString();

          if (s.indexOf(".") > -1) s = (n * 100).toFixed(0);
          else s += "00";

          if (s.length > unit.length) return "金额过大";
          unit = unit.substr(unit.length - s.length);

          for (let i = 0; i < s.length; i++) {
            str += "零壹贰叁肆伍陆柒捌玖".charAt(s.charAt(i)) + unit.charAt(i);
          }

          return str
            .replace(/零(仟|佰|拾|角)/g, "零")
            .replace(/(零)+/g, "零")
            .replace(/零(兆|万|亿|元)/g, "$1")
            .replace(/(兆|亿)万/g, "$1")
            .replace(/(京|兆)亿/g, "$1")
            .replace(/(京)兆/g, "$1")
            .replace(/(亿)万/g, "$1")
            .replace(/(京|兆|亿|仟|佰|拾)(万?)(.)/g, "$1$2$3")
            .replace(/零元/g, "元")
            .replace(/零分/g, "")
            .replace(/零角/g, "零")
            .replace(/元$/g, "元整")
            .replace(/角$/g, "角整");
        }

        /**
         * 将文件读取为 Base64 编码字符串
         * @param {File} file - 要读取的文件对象
         * @returns {Promise<string>} Base64 编码的数据 URL（包含 data:image/...;base64, 前缀）
         * @throws {Error} 文件读取失败时抛出错误
         * 用途：将礼簿封面图存储到 IndexedDB
         */
        static async readFileAsBase64(file) {
          return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = reject;
            reader.readAsDataURL(file);
          });
        }

        /**
         * 获取当前日期时间的格式化字符串
         * @returns {{date: string, time: string}} 包含 date 和 time 的对象
         * @example
         *   Utils.getCurrentDateTime()
         *   // => { date: "2025-10-12", time: "14:30" }
         * 用途：为创建事项表单设置默认时间
         */
        static getCurrentDateTime() {
          const now = new Date();
          const pad = (num) => num.toString().padStart(2, "0");
          const date = `${now.getFullYear()}-${pad(now.getMonth() + 1)}-${pad(now.getDate())}`;
          const time = `${pad(now.getHours())}:${pad(now.getMinutes())}`;
          return { date, time };
        }

        /**
         */
        static getEventDateInfo(dateInput) {
          const date = new Date(dateInput);
          if (Number.isNaN(date.getTime())) {
            return { date, formattedDisplay: "", localeDate: "" };
          }
          const formattedDisplay = `${date.getFullYear()}年${date.getMonth() + 1}月${date.getDate()}日`;
          return {
            date,
            formattedDisplay,
            localeDate: date.toLocaleDateString("zh-CN"),
          };
        }

        /**
         * 生成用于文件名的时间戳
         * @param {Date} date
         * @returns {string} yyyy-mm-dd hh:mm:ss
         */
        static formatTimestampForFilename(date = new Date()) {
          const pad = (num) => num.toString().padStart(2, "0");
          return `${date.getFullYear()}-${pad(date.getMonth() + 1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
        }

        /**
         * @returns {boolean}
         */
        static isMobile() {
          // 一个通用且可靠的移动设备检测方法
          return /Mobi|Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
        }
      }

      /**
       * 加密管理器 - 处理所有加密相关操作
       * 使用 CryptoJS 库实现 AES 加密和 SHA-256 哈希
       * 用途：保护礼金数据的隐私性和完整性
       */
      class CryptoService {
        /**
         * 加密数据 - 使用 AES 对称加密算法
         * @param {Object} data - 要加密的数据对象（会先转为JSON字符串）
         * @param {string} key - 加密密钥（用户输入的密码）
         * @returns {string} 加密后的密文字符串
         */
        static encrypt(data, key) {
          return CryptoJS.AES.encrypt(JSON.stringify(data), key).toString();
        }

        /**
         * 解密数据 - 使用 AES 对称解密算法
         * @param {string} ciphertext - 密文字符串
         * @param {string} key - 解密密钥（必须与加密时的密钥一致）
         * @returns {Object|null} 解密后的数据对象，失败时返回 null
         */
        static decrypt(ciphertext, key) {
          try {
            const bytes = CryptoJS.AES.decrypt(ciphertext, key);
            return JSON.parse(bytes.toString(CryptoJS.enc.Utf8));
          } catch (e) {
            console.error("解密失败:", e);
            return null; // 密钥错误或数据损坏时返回null
          }
        }

        /**
         * 哈希密码 - 使用 SHA-256 单向哈希算法
         * @param {string} password - 原始密码
         * @returns {string} 哈希值（用于密码验证，不可逆）
         * 注意：哈希值存储在数据库中，用于验证密码而不存储明文
         */
        static hash(password) {
          return CryptoJS.SHA256(password).toString();
        }
      }

      /**
       * 数据库管理器 - IndexedDB 封装
       * 提供对浏览器本地数据库的统一操作接口
       * 存储结构：
       *   - events: 事项信息（包含名称、时间、密码哈希、主题等）
       *   - gifts: 礼金记录（包含加密数据和关联的事项ID）
       */
      class DBManager {
        /**
         */
        constructor() {
          this.db = null; // IndexedDB 数据库连接对象
        }

        /**
         * 初始化数据库 - 打开或创建 IndexedDB 数据库
         * @returns {Promise<void>} 初始化完成后 resolve
         */
        async init() {
          return new Promise((resolve, reject) => {
            const request = indexedDB.open(CONFIG.DB_NAME, CONFIG.DB_VERSION);

            request.onerror = () => reject(request.error);

            request.onsuccess = () => {
              this.db = request.result;
              // 初始化成功后，直接 resolve 即可，无需返回任何信息
              resolve();
            };

            // 数据库升级事件 - 仅在首次创建数据库时触发
            request.onupgradeneeded = (event) => {
              const db = event.target.result;
              console.log("首次创建数据库，版本:", db.version);

              // 1. 创建 events 表
              if (!db.objectStoreNames.contains("events")) {
                db.createObjectStore("events", { keyPath: "id", autoIncrement: true });
              }

              // 2. 创建 gifts 表并建立所有需要的索引
              if (!db.objectStoreNames.contains("gifts")) {
                const giftStore = db.createObjectStore("gifts", { keyPath: "id", autoIncrement: true });
                giftStore.createIndex("eventId", "eventId", { unique: false });
                giftStore.createIndex("byEventAndLevel", ["eventId", "guestLevelWeight", "levelUpdateTime", "id"], { unique: false });
              }
            };
          });
        }

        /**
         * 根据复合索引进行排序查询
         * @param {string} storeName 表名
         * @param {string} indexName 索引名
         * @param {*} key1 复合索引的第一个键 (eventId)
         * @returns {Promise<Array>} 排序后的结果数组
         *
         * 排序逻辆（由 IndexedDB 索引自动完成）:
         * 1. 按 guestLevelWeight 降序 (等级高的在前)
         * 2. 相同等级内按 levelUpdateTime 降序 (修改过等级的在前，0 排在后)
         * 3. levelUpdateTime 相同时按 id 升序 (录入顺序)
         *
         * 注意：为了实现降序，需要在内存中进行排序，因为 IndexedDB 索引只支持升序
         */
        async getAllByCompoundIndex(storeName, indexName, key1) {
          const transaction = this.db.transaction(storeName, "readonly");
          const store = transaction.objectStore(storeName);
          const index = store.index(indexName);

          return new Promise((resolve, reject) => {
            const results = [];
            // 使用游标遍历，只获取匹配 eventId 的记录
            const range = IDBKeyRange.bound([key1, -Infinity, -Infinity, -Infinity], [key1, Infinity, Infinity, Infinity]);

            const request = index.openCursor(range);

            request.onsuccess = (event) => {
              const cursor = event.target.result;
              if (cursor) {
                results.push(cursor.value);
                cursor.continue();
              } else {
                // 排序：等级降序 -> levelUpdateTime 降序 -> id 升序
                // 注意：这里必须排序，因为 IndexedDB 索引只能升序，我们需要降序
                results.sort((a, b) => {
                  const weightDiff = (b.guestLevelWeight || 0) - (a.guestLevelWeight || 0);
                  if (weightDiff !== 0) return weightDiff;

                  // levelUpdateTime 降序（0 排在最后）
                  const aTime = a.levelUpdateTime || 0;
                  const bTime = b.levelUpdateTime || 0;
                  const timeDiff = bTime - aTime;
                  if (timeDiff !== 0) return timeDiff;

                  // id 升序（录入顺序）
                  return (a.id || 0) - (b.id || 0);
                });
                resolve(results);
              }
            };

            request.onerror = () => reject(request.error);
          });
        }
        /**
         */
        async add(storeName, data) {
          const transaction = this.db.transaction(storeName, "readwrite");
          const store = transaction.objectStore(storeName);
          return new Promise((resolve, reject) => {
            const request = store.add(data);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }

        /**
         */
        async get(storeName, key) {
          const transaction = this.db.transaction(storeName, "readonly");
          const store = transaction.objectStore(storeName);
          return new Promise((resolve, reject) => {
            const request = store.get(key);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }

        /**
         */
        async getAll(storeName) {
          const transaction = this.db.transaction(storeName, "readonly");
          const store = transaction.objectStore(storeName);
          return new Promise((resolve, reject) => {
            const request = store.getAll();
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }

        /**
         */
        async getAllByIndex(storeName, indexName, value) {
          const transaction = this.db.transaction(storeName, "readonly");
          const store = transaction.objectStore(storeName);
          const index = store.index(indexName);
          return new Promise((resolve, reject) => {
            const request = index.getAll(value);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }

        /**
         */
        async update(storeName, data) {
          const transaction = this.db.transaction(storeName, "readwrite");
          const store = transaction.objectStore(storeName);
          return new Promise((resolve, reject) => {
            const request = store.put(data);
            request.onsuccess = () => resolve(request.result);
            request.onerror = () => reject(request.error);
          });
        }

        /**
         */
        async delete(storeName, key) {
          const transaction = this.db.transaction(storeName, "readwrite");
          const store = transaction.objectStore(storeName);
          return new Promise((resolve, reject) => {
            const request = store.delete(key);
            request.onsuccess = () => resolve();
            request.onerror = () => reject(request.error);
          });
        }
      }

      /**
       * UI管理器 - DOM操作封装
       */
      class UIManager {
        constructor() {
          this.elements = this.cacheElements();
          this.elements.modalCloseBtn?.addEventListener("click", () => this.closeModal());
        }

        cacheElements() {
          const $ = (id) => document.getElementById(id);
          return {
            setupScreen: $("setup-screen"),
            mainScreen: $("main-screen"),
            eventSelector: $("event-selector"),
            unlockEventBtn: $("unlock-event-btn"),
            createEventForm: $("create-event-form"),
            addGiftForm: $("add-gift-form"),
            giftBookContent: $("gift-book-content"),
            totalAmountEl: $("total-amount"),
            pageSubtotalEl: $("page-subtotal"),
            totalGiversEl: $("total-givers"),
            pageInfoEl: $("page-info"),
            prevPageBtn: $("prev-page-btn"),
            nextPageBtn: $("next-page-btn"),
            currentEventTitleEl: $("current-event-title"),
            eventSwitcherTrigger: $("event-switcher-trigger"),
            eventDropdown: $("event-dropdown"),
            printBtn: $("print-btn"),
            exportExcelBtn: $("export-excel-btn"),
            statsBtn: $("stats-btn"),
            searchNameInput: $("search-name"),
            searchIcon: $("search-icon"),
            selectEventSection: $("select-event-section"),
            speechToggle: $("speech-toggle"),
            modalContainer: $("modal-container"),
            modal: $("modal"),
            modalTitle: $("modal-title"),
            modalContent: $("modal-content"),
            modalActions: $("modal-actions"),
            modalCloseBtn: $("modal-close-btn"),
            guestNameInput: $("guest-name"),
            giftAmountInput: $("gift-amount"),
            eventNameInput: $("event-name"),
            startDateInput: $("start-date"),
            startTimeInput: $("start-time"),
            endDateInput: $("end-date"),
            endTimeInput: $("end-time"),
            adminPasswordInput: $("admin-password"),
            eventThemeSelect: $("event-theme"),
            eventVoiceSelect: $("event-voice"),
            previewCreateVoiceBtn: $("preview-create-voice-btn"),
            fullscreenBtn: $("fullscreen-btn"),
            fullscreenIcon: $("fullscreen-icon"),
            supportBtn: $("support-btn"),
          };
        }

        showScreen(screen) {
          if (screen === "setup") {
            this.elements.mainScreen.classList.add("hidden");
            this.elements.setupScreen.classList.remove("hidden");
          } else if (screen === "main") {
            this.elements.setupScreen.classList.add("hidden");
            this.elements.mainScreen.classList.remove("hidden");
          }
        }

        /**
         * 显示模态对话框 - 统一的弹窗显示接口
         * @param {string} title - 对话框标题（支持HTML）
         * @param {string} content - 对话框内容（支持HTML）
         * @param {Array<Object>} actions - 按钮数组，每个元素包含：
         *   - text: 按钮文字
         *   - class: CSS类名
         *   - handler: 点击回调函数
         *   - keepOpen: 是否保持弹窗打开（默认关闭）
         *   - id: 可选，按钮ID
         *   - role: 可选，按钮角色（primary/secondary）。默认最后一个为 primary
         */
        showModal(title, content, actions = []) {
          // 设置对话框内容
          this.elements.modalTitle.innerHTML = title;
          this.elements.modalContent.innerHTML = content;
          // 确保按钮区域可见（防止被先前流程隐藏）
          this.elements.modalActions.classList.remove("hidden");
          this.elements.modalActions.innerHTML = ""; // 清空旧按钮防止重复

          // 动态创建按钮
          let primaryButton = null;
          actions.forEach((action, idx) => {
            const button = document.createElement("button");
            button.innerHTML = action.text;
            button.className = `${action.class} themed-ring focus:outline-none`;
            if (action.id) button.id = action.id;
            const role = action.role || (idx === actions.length - 1 ? "primary" : "secondary");
            button.dataset.role = role;
            button.onclick = () => {
              action.handler?.(); // 执行回调（如果存在）
              if (!action.keepOpen) this.closeModal(); // 除非指定保持打开，否则自动关闭
            };
            if (role === "primary") primaryButton = button;
            this.elements.modalActions.appendChild(button);
          });

          // 显示对话框并锁定背景滚动
          this.elements.modalContainer.classList.remove("hidden");
          document.body.style.overflow = "hidden";

          // 将焦点默认设置到主操作按钮，避免回车触发取消
          if (primaryButton) setTimeout(() => primaryButton.focus(), 10);
        }

        /**
         */
        closeModal() {
          this.elements.modalContainer.classList.add("hidden");
          this.elements.modal.classList.remove("modal-large");
          document.body.style.overflow = "auto";
        }

        /**
         */
        showNotification(message, type = "info") {
          const notification = document.createElement("div");
          notification.className = "fixed top-5 right-5 flex items-center px-4 py-3 rounded-lg shadow-xl text-white z-[100] transition-all duration-500 ease-in-out opacity-0 -translate-y-full";

          const styles = {
            info: { icon: "ri-information-line", bg: "bg-blue-600" },
            success: { icon: "ri-check-line", bg: "bg-green-600" },
            error: { icon: "ri-error-warning-line", bg: "themed-button-primary" },
          };

          const style = styles[type] || styles.info;
          notification.classList.add(style.bg);
          notification.innerHTML = `<i class="${style.icon} text-xl mr-1"></i><span>${message}</span>`;

          document.body.appendChild(notification);
          setTimeout(() => notification.classList.remove("opacity-0", "-translate-y-full"), 10);

          setTimeout(() => {
            notification.classList.add("opacity-0", "-translate-y-full");
            notification.addEventListener("transitionend", () => notification.remove());
          }, 3000);
        }

        /**
         */
        applyTheme(theme) {
          document.body.className = `bg-gray-100 flex items-center justify-center min-h-screen ${theme || "theme-festive"}`;
        }
      }

      /**
       * 数据网关 - 封装 DBManager 的业务级访问接口
       */
      class GiftRepository {
        /**
         */
        constructor(database) {
          this.database = database;
        }

        /**
         */
        async fetchAllEvents() {
          return this.database.getAll("events");
        }

        /**
         */
        async fetchEvent(eventId) {
          return this.database.get("events", eventId);
        }

        /**
         */
        async createEvent(event) {
          return this.database.add("events", event);
        }

        /**
         */
        async updateEvent(event) {
          return this.database.update("events", event);
        }

        /**
         */
        async deleteEvent(eventId) {
          return this.database.delete("events", eventId);
        }

        /**
         */
        async fetchOrderedGifts(eventId) {
          return this.database.getAllByCompoundIndex("gifts", "byEventAndLevel", eventId);
        }

        /**
         */
        async fetchGiftsByEvent(eventId) {
          return this.database.getAllByIndex("gifts", "eventId", eventId);
        }

        /**
         */
        async createGift(gift) {
          return this.database.add("gifts", gift);
        }

        /**
         */
        async updateGift(gift) {
          return this.database.update("gifts", gift);
        }

        /**
         */
        async deleteGift(giftId) {
          return this.database.delete("gifts", giftId);
        }
      }

      class SessionManager {
        /**
         * @param {string} [storageKey="activeEventSession"] - sessionStorage key
         */
        constructor(storageKey = "activeEventSession") {
          this.storageKey = storageKey;
        }

        /**
         */
        save(event, password) {
          const encryptedPassword = CryptoJS.AES.encrypt(password, event.passwordHash).toString();
          sessionStorage.setItem(this.storageKey, JSON.stringify({ event, encryptedPassword }));
        }

        /**
         */
        load() {
          const stored = sessionStorage.getItem(this.storageKey);
          if (!stored) return null;
          try {
            return JSON.parse(stored);
          } catch (error) {
            console.error("会话读取失败", error);
            sessionStorage.removeItem(this.storageKey);
            return null;
          }
        }

        /**
         */
        clear() {
          sessionStorage.removeItem(this.storageKey);
        }

        /**
         */
        _notificationKey(eventId) {
          return `eventEndedNotif_${eventId}`;
        }

        /**
         */
        hasNotification(eventId) {
          return !!sessionStorage.getItem(this._notificationKey(eventId));
        }

        /**
         */
        markNotification(eventId) {
          sessionStorage.setItem(this._notificationKey(eventId), "true");
        }
      }

      class PasswordCache {
        /**
         */
        constructor(durationMinutes) {
          this.durationMinutes = durationMinutes;
          this.storagePrefix = "adminPwdCache_";
        }

        /**
         */
        _key(eventId) {
          return `${this.storagePrefix}${eventId}`;
        }

        /**
         */
        store(eventId, password, passwordHash) {
          try {
            const encrypted = CryptoJS.AES.encrypt(password, passwordHash).toString();
            const expireTime = Date.now() + this.durationMinutes * 60 * 1000;
            localStorage.setItem(this._key(eventId), JSON.stringify({ encrypted, expireTime }));
          } catch (error) {
            console.error("密码缓存失败:", error);
          }
        }

        /**
         */
        retrieve(eventId, passwordHash) {
          try {
            const cached = localStorage.getItem(this._key(eventId));
            if (!cached) return null;
            const { encrypted, expireTime } = JSON.parse(cached);
            if (Date.now() > expireTime) {
              localStorage.removeItem(this._key(eventId));
              return null;
            }
            const bytes = CryptoJS.AES.decrypt(encrypted, passwordHash);
            return bytes.toString(CryptoJS.enc.Utf8);
          } catch (error) {
            console.error("密码缓存读取失败:", error);
            return null;
          }
        }

        /**
         */
        clear(eventId) {
          localStorage.removeItem(this._key(eventId));
        }
      }

      /**
       * 统计礼金记录姓名纠错的次数
       * - 兼容旧历史记录中未写入 changedFields 的情况
       * - 仅统计类型为 correction 的历史节点
       * @param {Array} history - 礼金历史记录
       * @returns {number} 已经执行的姓名纠错次数
       */
      function countNameCorrections(history) {
        if (!Array.isArray(history)) return 0;
        return history.reduce((total, entry) => {
          if (!entry || entry.type !== "correction") return total;
          if (Array.isArray(entry.changedFields) && entry.changedFields.includes("name")) return total + 1;
          if (typeof entry.changeLog === "string" && entry.changeLog.includes("纠错姓名")) return total + 1;
          return total;
        }, 0);
      }

      /**
       * 统计礼金记录金额被修改的次数
       * @param {Array} history - 礼金历史记录
       * @returns {number} 已经执行的金额调整次数
       */
      function countAmountCorrections(history) {
        if (!Array.isArray(history)) return 0;
        return history.reduce((total, entry) => {
          if (!entry || entry.type !== "correction") return total;
          if (Array.isArray(entry.changedFields) && entry.changedFields.includes("amount")) return total + 1;
          if (typeof entry.changeLog === "string" && (/金额/.test(entry.changeLog) || entry.changeLog.toLowerCase().includes("amount"))) return total + 1;
          return total;
        }, 0);
      }

      class GiftManager {
        /**
         */
        constructor(app) {
          this.app = app;
        }

        /**
         * 构造写回数据库所需的礼金记录对象
         * 仅保留索引字段与密文，避免将解密数据写入 IndexedDB
         */
        buildGiftRecordForUpdate(giftObject, overrides = {}) {
          if (!giftObject) return { ...overrides };
          return {
            id: giftObject.id,
            eventId: giftObject.eventId,
            guestLevelWeight: giftObject.guestLevelWeight ?? 0,
            levelUpdateTime: giftObject.levelUpdateTime ?? 0,
            encryptedData: giftObject.encryptedData,
            ...overrides,
          };
        }

        /**
         */
        generateGiftCellHTML(gift, giftIndex) {
          const app = this.app;
          const g = gift.data;
          // 统计姓名与金额纠错次数，用于限制按钮状态
          const isModified = g.history?.some((h) => h.type === "correction");
          const hasRemarks = app.hasRemarkData(g);
          const isAbolished = g.abolished === true;

          const statusIndicators = `<div class="mark">
                            ${hasRemarks ? "<p>*已备注</p>" : ""}
                            ${isModified ? "<p>*已修改</p>" : ""}
                            ${isAbolished ? '<p class="text-red-600">*已作废</p>' : ""}
                          </div>`;

          const nameClasses = isAbolished ? "opacity-50" : "";
          const amountClasses = isAbolished ? "opacity-50 line-through" : "";

          const amountChinese = Utils.amountToChinese(g.amount);
          const displayName = g.name.length === 2 ? `${g.name[0]}\u3000${g.name[1]}` : g.name;
          return {
            nameHTML: `<div class="name ${g.name.length > 4 ? "scale" : ""} ${nameClasses}">${displayName}</div>${statusIndicators}`,
            amountHTML: `<div class="amount-chinese ${amountChinese.length > 16 ? "scale" : ""} ${amountClasses}">${amountChinese}</div>
                      <div class="amount-numeric ${Math.abs(g.amount).toString().length > 8 ? "scale" : ""} ${amountClasses}">￥${g.amount}</div>`,
            giftIndex,
          };
        }

        /**
         * 性能优化：增量渲染单条礼金记录
         * 只更新下一个空位，而不是重绘整个页面
         * 优势：
         * - 避免全页重绘，提升性能
         * - 减少 DOM 操作次数
         * - 提供更流畅的用户体验
         */
        renderSingleGift(gift, giftIndex) {
          const app = this.app;
          if (!gift?.data) return;
          const itemIndexOnPage = giftIndex % app.getItemsPerPage();
          const nameCells = app.ui.elements.giftBookContent.querySelectorAll(".name-cell");
          const amountCells = app.ui.elements.giftBookContent.querySelectorAll(".amount-cell");

          const targetNameCell = nameCells[itemIndexOnPage];
          const targetAmountCell = amountCells[itemIndexOnPage];

          if (!targetNameCell || !targetAmountCell) {
            app.giftManager.render();
            app.guestScreenService.syncToGuestScreen();
            return;
          }

          const { nameHTML, amountHTML } = app.giftManager.generateGiftCellHTML(gift, giftIndex);
          targetNameCell.innerHTML = nameHTML;
          targetNameCell.dataset.giftIndex = giftIndex;
          targetAmountCell.innerHTML = amountHTML;
          targetAmountCell.dataset.giftIndex = giftIndex;
        }

        /**
         * 性能优化：增量更新单条礼金记录 DOM
         * 只更新指定位置的单元格，避免整页重新渲染
         * @param {number} giftIndex - 礼金索引
         * @param {object} updatedData - 最新的礼金数据
         */
        updateSingleGiftDOM(giftIndex, updatedData) {
          const app = this.app;
          const targetNameCell = app.ui.elements.giftBookContent.querySelector(`.name-cell[data-gift-index="${giftIndex}"]`);
          const targetAmountCell = app.ui.elements.giftBookContent.querySelector(`.amount-cell[data-gift-index="${giftIndex}"]`);

          if (!targetNameCell || !targetAmountCell) return;

          const { nameHTML, amountHTML } = app.giftManager.generateGiftCellHTML({ data: updatedData }, giftIndex);
          targetNameCell.innerHTML = nameHTML;
          targetAmountCell.innerHTML = amountHTML;
        }

        /**
         * 性能优化：重建缓存数据
         * 重新计算总金额、总人数等统计信息
         * 在加载事项或批量解密后调用
         */
        rebuildCache() {
          const app = this.app;
          app.totalAmountCache = app.gifts.reduce((sum, gift) => {
            return gift.data && !gift.data.abolished ? sum + gift.data.amount : sum;
          }, 0);
          app.totalGiversCache = app.gifts.filter((g) => g.data && !g.data.abolished).length;
          app.statsAreDirty = true; // 标记统计详情需要重新计算
        }

        /**
         * 性能优化：增量更新缓存（添加记录）
         * 直接在缓存上累加金额与人数，避免重新遍历
         * @param {number} amount - 新增记录金额
         */
        updateCacheOnAdd(amount) {
          const app = this.app;
          app.totalAmountCache += amount;
          app.totalGiversCache += 1;
          app.statsAreDirty = true;
        }

        /**
         * 性能优化：增量更新缓存（修改记录）
         * 根据金额差额更新缓存，避免重新遍历
         * @param {number} oldAmount - 原金额
         * @param {number} newAmount - 新金额
         */
        updateCacheOnUpdate(oldAmount, newAmount) {
          const app = this.app;
          app.totalAmountCache = app.totalAmountCache - oldAmount + newAmount;
          // 人数不变
          app.statsAreDirty = true;
        }

        /**
         * 统一的解密方法 - 避免代码冗余
         * 解密指定范围内的礼金记录，自动跳过已解密条目
         * @param {number} startIdx - 起始索引（包含）
         * @param {number} endIdx - 结束索引（不包含）
         * @returns {number} 实际解密记录数
         */
        decryptGiftsRange(startIdx, endIdx) {
          const app = this.app;
          if (app.allGiftsDecrypted) {
            return 0; // 没有解密任何新条目
          }
          let decryptedCount = 0;
          const actualEnd = Math.min(endIdx, app.gifts.length);

          for (let i = startIdx; i < actualEnd; i++) {
            if (app.gifts[i] && app.gifts[i]._needsDecrypt) {
              const decryptedData = CryptoService.decrypt(app.gifts[i].encryptedData, app.currentPassword);
              app.gifts[i].data = decryptedData;
              app.gifts[i]._needsDecrypt = false;
              app.gifts[i].encryptedData = null; // 释放内存
              decryptedCount++;
            }
          }

          return decryptedCount;
        }

        /**
         * 加载当前事项的所有礼金记录
         * 使用复合索引查询，结果按等级与更新时间排序
         * @returns {Promise<void>}
         */
        async loadGiftsForCurrentEvent() {
          const app = this.app;
          app.allGiftsDecrypted = false;
          const encryptedGifts = await app.giftRepository.fetchOrderedGifts(app.currentEvent.id);

          // 容错处理：确保所有记录都有 guestLevelWeight 和 levelUpdateTime
          app.gifts = encryptedGifts.map((g) => {
            if (g.guestLevelWeight === undefined || g.guestLevelWeight === null) {
              g.guestLevelWeight = 0; // 默认等级
            }
            if (g.levelUpdateTime === undefined || g.levelUpdateTime === null) {
              g.levelUpdateTime = 0; // 默认为 0（未修改过等级）
            }
            return { ...g, data: null, _needsDecrypt: true };
          });
          const pageSize = app.getItemsPerPage();
          const totalPages = Math.ceil(app.gifts.length / pageSize) || 1;

          // 智能选择初始页码：已结束显示第一页，进行中显示最后一页
          const now = new Date();
          const endTime = new Date(app.currentEvent.endDateTime);
          const isEventEnded = now > endTime;
          app.currentPage = isEventEnded ? 1 : totalPages;
          if (!this.allGiftsDecrypted) {
            // 解密当前页数据
            const pageStart = (app.currentPage - 1) * pageSize;
            const pageEnd = Math.min(pageStart + pageSize, app.gifts.length);
            app.giftManager.decryptGiftsRange(pageStart, pageEnd);
          }

          app.giftManager.rebuildCache();
          app.giftManager.render();

          // 异步解密剩余数据
          if (app.gifts.length > 0) {
            const scheduleIdle = typeof requestIdleCallback === "function" ? requestIdleCallback : (cb) => setTimeout(cb, 16);
            scheduleIdle(() => app.giftManager.decryptRemainingGifts(0));
          }
        }

        /**
         * 利用 requestIdleCallback 在浏览器空闲时解密
         * 避免一次性解密阻塞主线程，大量数据时分批处理
         */
        async decryptRemainingGifts(startIndex) {
          const app = this.app;
          const BATCH_SIZE = 300;
          let didDecrypt = false;

          for (let i = startIndex; i < app.gifts.length; i += BATCH_SIZE) {
            const batchEnd = Math.min(i + BATCH_SIZE, app.gifts.length);

            // 使用统一的解密方法
            const decryptedCount = app.giftManager.decryptGiftsRange(i, batchEnd);
            if (decryptedCount > 0) {
              didDecrypt = true;
            }

            // 等待浏览器空闲再继续
            await new Promise((resolve) => {
              if ("requestIdleCallback" in window) {
                requestIdleCallback(resolve);
              } else {
                setTimeout(resolve, 16); //
              }
            });

            // 更新缓存和 UI
            if (didDecrypt) {
              app.giftManager.rebuildCache();
              app.giftManager.updateTotals();
              didDecrypt = false; // 重置标志
            }
          }
          app.allGiftsDecrypted = true; // 标记所有数据已解密
        }

        /**
         * 渲染主界面 - 统一入口
         * 依次渲染礼簿、更新统计与分页信息
         */
        render() {
          const app = this.app;
          app.giftManager.renderGiftBook();
          app.giftManager.updateTotals();
          app.giftManager.updatePageInfo();
        }

        /**
         * 渲染礼簿内容 - 生成当前页 DOM
         * 使用 DocumentFragment 一次性插入，减少重排
         */
        renderGiftBook() {
          const app = this.app;
          const pageSize = app.getItemsPerPage();
          const items = app.gifts.slice((app.currentPage - 1) * pageSize, app.currentPage * pageSize);
          app.ui.elements.giftBookContent.innerHTML = "";
          app.ui.elements.giftBookContent.appendChild(app.exportService.createGiftBookRows(items, false, pageSize));
        }

        /**
         * 更新界面统计数据显示
         * 计算本页小计并展示缓存的总额、总人数
         */
        updateTotals() {
          const app = this.app;
          const itemsOnPage = app.gifts.slice((app.currentPage - 1) * app.getItemsPerPage(), app.currentPage * app.getItemsPerPage());
          // 只计算未作废记录的金额
          const pageSubtotal = itemsOnPage.reduce((sum, gift) => {
            if (gift.data && !gift.data.abolished) {
              return sum + gift.data.amount;
            }
            return sum;
          }, 0);
          app.ui.elements.pageSubtotalEl.textContent = Utils.formatCurrency(pageSubtotal);
          app.ui.elements.totalAmountEl.textContent = Utils.formatCurrency(app.totalAmountCache);
          app.ui.elements.totalGiversEl.textContent = app.totalGiversCache;
        }

        /**
         */
        updatePageInfo() {
          const app = this.app;
          const totalPages = Math.ceil(app.gifts.length / app.getItemsPerPage()) || 1;
          app.ui.elements.pageInfoEl.innerHTML = `
                        第
                        <input type="number" id="current-page-input" value="${app.currentPage}"
                              min="1" max="${totalPages}"
                              class="w-[${app.currentPage.toString().length}em] text-center bg-transparent themed-ring rounded border p-0 mx-2 font-bold focus:w-[4em]">
                        / ${totalPages} 页
                      `;
          app.ui.elements.prevPageBtn.disabled = app.currentPage === 1;
          app.ui.elements.nextPageBtn.disabled = app.currentPage === totalPages;
        }

        /**
         * 翻页功能
         * @param {number} direction - 方向：1 为下一页，-1 为上一页
         */
        changePage(direction) {
          const app = this.app;
          const totalPages = Math.ceil(app.gifts.length / app.getItemsPerPage()) || 1;
          const newPage = app.currentPage + direction;

          if (newPage >= 1 && newPage <= totalPages) {
            app.currentPage = newPage;
            app.giftManager.ensureCurrentPageDecrypted();
            app.giftManager.render();
          }
          app.guestScreenService.syncToGuestScreen();
        }

        /**
         * 确保当前页数据解密 - 懒加载优化策略
         * 只解密当前页需要显示的数据，减少内存占用和加载时间
         * 原理：利用 _needsDecrypt 标志位跟踪哪些数据需要解密
         * 性能：对于大量数据（>500条）可显著提升页面响应速度
         */
        ensureCurrentPageDecrypted() {
          const app = this.app;
          // 计算当前页的起始和结束索引
          const start = (app.currentPage - 1) * app.getItemsPerPage();
          const end = Math.min(start + app.getItemsPerPage(), app.gifts.length);

          // 使用统一的解密方法
          !this.allGiftsDecrypted && app.giftManager.decryptGiftsRange(start, end);
        }

        /**
         * 按等级+等级修改时间排序礼金数组（通用方法）
         * 排序逻辑：
         * 1. 等级降序（高等级在前）
         * 2. 相同等级内按 levelUpdateTime 降序（修改过等级的在前）
         * 3. levelUpdateTime 相同时按 id 升序（录入顺序）
         */
        sortGiftsByLevel() {
          const app = this.app;
          app.gifts.sort((a, b) => {
            const weightDiff = (b.guestLevelWeight || 0) - (a.guestLevelWeight || 0);
            if (weightDiff !== 0) return weightDiff;

            // levelUpdateTime 降序（0 排在最后）
            const aTime = a.levelUpdateTime || 0;
            const bTime = b.levelUpdateTime || 0;
            const timeDiff = bTime - aTime;
            if (timeDiff !== 0) return timeDiff;

            // id 升序（录入顺序）
            return (a.id || 0) - (b.id || 0);
          });
        }

        /**
         * 创建数据快照（通用方法）- 确保快照信息完整
         * @param {Object} data - 原始数据 (修改前的状态)
         * @param {Object} changedFields - 变化的字段 (可选)
         * @returns {Object} 快照对象
         */
        createSnapshot(data, changedFields = null) {
          const app = this.app;
          const snapshot = {
            name: data.name,
            amount: data.amount,
            type: data.type, // 确保 type 字段总是被包含
            remarkData: data.remarkData, // 包含当前的备注对象
            guestLevel: data.guestLevel !== undefined ? data.guestLevel : 0,
            timestamp: data.timestamp,
          };

          // 如果传入了 changedFields，用 data 中对应的旧值覆盖快照中的字段
          // 这一步确保了快照记录的是 *变化发生前* 的确切状态
          if (changedFields && typeof changedFields === "object") {
            Object.keys(changedFields).forEach((key) => {
              if (data.hasOwnProperty(key)) {
                snapshot[key] = data[key];
              }
            });
          }

          return snapshot;
        }

        /**
         * 执行礼金数据更新的统一入口
         * - 兼容姓名纠错、金额调整、备注更新等场景
         * - 在提交前处理管理员密码核验与历史记录快照
         * - 成功后同步更新本地缓存、统计信息与界面
         */
        async performUpdate(giftIndex, newFields, changeLogText, updateType) {
          const app = this.app;
          const giftObject = app.gifts[giftIndex];
          if (!giftObject || !giftObject.data) return;

          const currentData = { ...giftObject.data };
          const changedFieldKeys = Object.keys(newFields || {}).filter((key) => Object.prototype.hasOwnProperty.call(currentData, key) && currentData[key] !== newFields[key]);

          // 根据变更类型判断是否需要管理员密码（纠错强制验证）
          let password = null;
          if (updateType === "correction") {
            const forceVerify = changedFieldKeys.includes("name") || changedFieldKeys.includes("amount");
            password = await app.requestAdminPassword("修改确认", "如要调整礼金信息，请输入管理员密码。", null, forceVerify);
          } else if (updateType === "remark") {
            const isOutOfTime = new Date() < new Date(app.currentEvent.startDateTime) || new Date() > new Date(app.currentEvent.endDateTime);
            if (isOutOfTime) {
              password = await app.requestAdminPassword("备注记录", "当前已超过有效录入时间，请输入管理员密码后继续修改备注。");
            } else {
              password = app.currentPassword; // 在有效时段内，直接使用当前密码
            }
          }

          if (password === null) {
            // 用户取消或验证失败，直接返回详情页
            app.showGiftDetails(giftIndex);
            return;
          }

          const oldAmount = currentData.amount;
          const now = new Date().toISOString();
          // 记录变更日志并补齐更新前的快照数据，便于回溯
          const historyEntry = {
            timestamp: now,
            changeLog: changeLogText,
            snapshot: app.giftManager.createSnapshot(currentData, newFields),
            type: updateType,
            changedFields: changedFieldKeys,
          };

          // 合并旧数据与新字段，并将历史记录追加至末尾
          const updatedData = {
            ...currentData,
            ...newFields,
            timestamp: now,
            history: currentData.history ? [...currentData.history, historyEntry] : [historyEntry],
          };
          const newAmount = updatedData.amount; // 获取最新版金额
          // 将最新数据加密保存，并在成功后刷新 UI 与统计信息
          try {
            const encryptedData = CryptoService.encrypt(updatedData, app.currentPassword);
            const recordToUpdate = this.buildGiftRecordForUpdate(giftObject, { encryptedData });
            await app.giftRepository.updateGift(recordToUpdate);

            app.gifts[giftIndex].data = updatedData;
            app.gifts[giftIndex].encryptedData = encryptedData;
            app.giftManager.updateSingleGiftDOM(giftIndex, updatedData);

            if (oldAmount !== newAmount) {
              app.giftManager.updateCacheOnUpdate(oldAmount, newAmount);
              app.giftManager.updateTotals();
            }
            app.ui.closeModal();
            app.ui.showNotification("修改成功", "success");
            app.guestScreenService.syncToGuestScreen();

            setTimeout(() => app.showGiftDetails(giftIndex), 300);
          } catch (error) {
            console.error("更新失败", error);
            app.ui.showNotification("更新记录失败，请稍后重试", "error");
            app.showGiftDetails(giftIndex);
          }
        }

        /**
         */
        async abolishGift(giftIndex) {
          const app = this.app;
          const gift = app.gifts[giftIndex];
          app.guestScreenService.syncToGuestScreen();
          if (!gift || !gift.data) return;
          if (gift.data.abolished) {
            app.ui.showNotification("该记录已被作废。");
            return;
          }

          // 输入作废理由
          const reason = await new Promise((resolve) => {
            app.ui.elements.modalActions.classList.remove("hidden");
            app.ui.elements.modal.classList.remove("modal-large");
            const content = `
                        <div class="space-y-3 text-left">
                          <p class="text-sm text-red-600">请输入作废理由（必填）：</p>
                          <textarea id="abolish-reason-input" class="w-full p-3 border rounded themed-ring" rows="4"
                            placeholder="例如：重复录入、错误记录、客人撤销礼金等"
                            required></textarea>
                          <p class="text-xs text-gray-500">注：作废后，该记录将保留在系统中但不计入总金额，并且不会在打印PDF时显示。</p>
                        </div>
                      `;
            app.ui.showModal("请输入作废理由", content, [
              { text: "取消", class: "themed-button-secondary border px-4 py-2 rounded", handler: () => resolve(null) },
              {
                text: "下一步",
                class: "themed-button-primary text-white px-4 py-2 rounded  ",
                handler: () => {
                  const reasonText = document.getElementById("abolish-reason-input").value.trim();
                  if (!reasonText) {
                    app.ui.showNotification("请填写作废理由。", "error");
                    return; // 保持弹窗打开
                  }
                  resolve(reasonText);
                },
                keepOpen: true,
              },
            ]);
            setTimeout(() => document.getElementById("abolish-reason-input")?.focus(), 50);
          });

          if (reason === null) {
            app.ui.closeModal();
            return;
          }

          // 校验管理员密码
          const password = await app.requestAdminPassword("作废确认", `即将作废 \"${gift.data.name}\" 的礼金记录。请输入管理密码以继续。`, null, true);

          if (password === null) return;

          // 执行作废操作
          try {
            const amountToAbolish = gift.data.amount;
            const currentData = { ...gift.data };
            const now = new Date().toISOString();

            const historyEntry = {
              timestamp: now,
              changeLog: `该记录已作废。，理由：${reason}`,
              snapshot: app.giftManager.createSnapshot(currentData),
              type: "abolish",
            };
            const updatedData = {
              ...currentData,
              abolished: true,
              abolishReason: reason,
              abolishTime: now,
              timestamp: now,
              history: currentData.history ? [...currentData.history, historyEntry] : [historyEntry],
            };
            const encryptedData = CryptoService.encrypt(updatedData, app.currentPassword);
            await app.giftRepository.updateGift(this.buildGiftRecordForUpdate(gift, { encryptedData }));

            app.gifts[giftIndex].data = updatedData;
            app.gifts[giftIndex].encryptedData = encryptedData;
            app.totalAmountCache -= amountToAbolish;
            app.totalGiversCache -= 1;
            app.statsAreDirty = true;
            app.giftManager.render();
            app.ui.closeModal();
            app.ui.showNotification("记录已作废。", "success");
            app.guestScreenService.syncToGuestScreen();
          } catch (error) {
            console.error("作废失败:", error);
            app.ui.showNotification("作废操作时发生未知错误，请重试。", "error");
          }
        }
      }
      class ExportService {
        constructor(app) {
          this.app = app;
        }

        /**
         * 准备打印/导出 PDF
         * 根据记录数量和设备环境决定打印方式，并在必要时提示配置
         */
        async prepareForPrint() {
          const app = this.app;
          // 计算有效记录数（不含作废）
          const activeGiftsCount = app.gifts.filter((g) => g.data && !g.data.abolished).length;

          if (activeGiftsCount === 0) {
            app.ui.showNotification("当前事项没有有效的礼金记录，无需打印。");
            return;
          }

          const canProceed = await app.exportService.ensurePrintPreferences();
          if (!canProceed) return;

          // 大量数据时显示分批选择对话框
          if (app.gifts.length > CONFIG.PRINT_SPLIT_THRESHOLD) {
            app.exportService.showPrintChunkModal();
            return;
          }

          // 少量数据直接打印
          const selectedEngine = app.currentEvent.printOptions?.pdfEngine || "browser";
          const shouldUsePdfLib = Utils.isMobile() || selectedEngine === "pdf-lib";

          if (shouldUsePdfLib) {
            // 移动端或强制 PDF-LIB 情况下直接生成 PDF
            app.exportService.generatePdf(0, app.gifts.length);
          } else {
            // 桌面设备上调用浏览器原生打印功能/生成 PDF
            app.exportService.executePrint(0, app.gifts.length);
          }
        }

        /**
         * 显示分批打印选择对话框
         * 用于记录数超阈值时按块导出
         */
        showPrintChunkModal() {
          const app = this.app;
          const chunkSize = CONFIG.PRINT_SPLIT_THRESHOLD;
          const totalChunks = Math.ceil(app.gifts.length / chunkSize);

          let contentHtml = `<p class="mb-4 text-sm text-gray-700">由于礼金记录数较多，为防止渲染时卡死，需要分批打印导出，请选择要导出的部分：</p>`;
          contentHtml += `<div class="space-y-2 border rounded-lg p-2 max-h-[50vh] overflow-y-auto">`;

          for (let i = 0; i < totalChunks; i++) {
            const startRecord = i * chunkSize + 1;
            const endRecord = Math.min((i + 1) * chunkSize, app.gifts.length);
            contentHtml += `
                      <div class="print-chunk-item flex justify-between items-center p-3 rounded-lg cursor-pointer themed-link-hover"
                           data-start="${i * chunkSize}" data-end="${endRecord}"
                           data-part-index="${i + 1}"
                           data-original-text="生成打印第 ${i + 1} 部分 (记录 ${startRecord} - ${endRecord})">
                        <span class="main-text">打印第 ${i + 1} 部分 (记录 ${startRecord} - ${endRecord})</span>
                        <span class="status-icon text-green-600 font-bold"></span>
                      </div>`;
          }
          contentHtml += `</div>`;

          app.ui.showModal("分批打印/导出PDF", contentHtml, [{ text: "关闭", class: "themed-button-secondary border px-4 py-2 rounded" }]);

          setTimeout(() => {
            document.querySelectorAll(".print-chunk-item").forEach((item) => {
              item.onclick = async (e) => {
                const el = e.currentTarget;
                if (el.dataset.status === "completed") return;
                const start = parseInt(el.dataset.start);
                const end = parseInt(el.dataset.end);
                const partIndex = parseInt(el.dataset.partIndex);
                const mainTextSpan = el.querySelector(".main-text");
                const originalText = el.dataset.originalText || "";
                mainTextSpan.textContent = "生成中...";
                el.classList.add("cursor-wait");

                const selectedEngine = app.currentEvent.printOptions?.pdfEngine || "browser";
                const usePdfLib = Utils.isMobile() || selectedEngine === "pdf-lib";
                if (usePdfLib) {
                  await app.exportService.generatePdf(start, end, partIndex);
                } else {
                  await app.exportService.executePrint(start, end, partIndex, totalChunks);
                }

                el.dataset.status = "completed";
                mainTextSpan.textContent = `${originalText} (已完成)`;
                const statusIcon = el.querySelector(".status-icon");
                statusIcon.innerHTML = "&#10004;";
                el.classList.remove("cursor-wait");
                el.classList.add("cursor-default", "opacity-70");
              };
            });
          }, 50);
        }

        /**
         * 生成 PDF
         * @param {number} startIndex - 起始索引
         * @param {number} endIndex - 结束索引
         * @param {number|null} partIndex - 分批编号（为 null 时表示不分批）
         */
        async generatePdf(startIndex, endIndex, partIndex = null) {
          const app = this.app;
          if (app.isGeneratingPdf) {
            app.ui.showNotification("正在生成 PDF，请勿重复操作...", "info");
            return;
          }

          const printBtn = app.ui.elements.printBtn;
          const originalBtnText = printBtn.innerHTML;
          const blobUrlsToRevoke = [];

          try {
            app.isGeneratingPdf = true;
            printBtn.disabled = true;
            printBtn.innerHTML = '<i class="ri-loader-4-line animate-spin mr-2"></i>正在生成...';
            app.ui.showNotification("正在生成 PDF 文件，请稍候...", "info");

            // ====================== 1. 解析自定义配置（统一处理“自定义 or 兜底”） ======================
            const customStyle = app.currentEvent.customStyle || {};
            const isSolemnTheme = app.currentEvent.theme === "theme-solemn";

            const resolve = {
              size: (val, fallback) => (Number(val) > 0 ? Number(val) : fallback),
              color: (val, fallback) => (typeof val === "string" && val.trim() ? val : fallback),
              font: (val) => (typeof val === "string" && val.trim() ? val : null),
            };

            const giftBookStyles = {
              name: { fontSize: resolve.size(customStyle.name?.size, 25), color: resolve.color(customStyle.name?.color, "#333333") },
              label: { fontSize: resolve.size(customStyle.type?.size, 22), color: resolve.color(customStyle.type?.color, isSolemnTheme ? "#374151" : "#cc0000") },
              amount: { fontSize: resolve.size(customStyle.amountChinese?.size, 25), color: resolve.color(customStyle.amountChinese?.color, "#333333") },
              coverText: { fontSize: resolve.size(customStyle.coverText?.size, 30), color: resolve.color(customStyle.coverText?.color, "#f5d4ab") },
              pageInfo: {
                fontSize: 12,
                themeColor: resolve.color(customStyle.pageInfo?.themeColor, isSolemnTheme ? "#374151" : "#ec403c"),
                baseColor: resolve.color(customStyle.pageInfo?.baseColor, "#1f2937"),
              },
            };

            // 自定义图片（封面 + 背景）
            const coverImageUrl = app.currentEvent.coverType === "custom" ? (await ImageCache.getEventCoverUrl(app.currentEvent.id)) || "./static/cover1.jpg" : "./static/cover1.jpg";

            const bgImageUrl = (await ImageCache.getBackgroundUrl(app.currentEvent.id)) || "./static/bg.jpg";

            // ====================== 2. 统一加载自定义字体 ======================
            const customFontNames = {
              name: resolve.font(customStyle.name?.font),
              label: resolve.font(customStyle.type?.font),
              amount: resolve.font(customStyle.amountChinese?.font),
              cover: resolve.font(customStyle.coverText?.font),
              pageInfo: resolve.font(customStyle.pageInfo?.font),
            };

            const fontBytesMap = { name: null, label: null, amount: null, cover: null, pageInfo: null };

            if (window.queryLocalFonts) {
              const loadFont = async (postscriptName, key) => {
                if (!postscriptName) return;
                try {
                  const fonts = await window.queryLocalFonts();
                  const font = fonts.find((f) => f.postscriptName === postscriptName);
                  if (font?.blob) {
                    const buffer = await font.blob().then((b) => b.arrayBuffer());
                    fontBytesMap[key] = new Uint8Array(buffer);
                  }
                } catch (e) {
                  console.warn(`加载字体失败: ${postscriptName}`, e);
                }
              };

              await Promise.all(Object.keys(customFontNames).map((key) => loadFont(customFontNames[key], key)));
            }

            // 转成 Blob URL（统一管理，finally 中 revoke）
            const createBlobUrl = (bytes) => {
              if (!bytes?.length) return null;
              const blob = new Blob([bytes], { type: "font/ttf" });
              const url = URL.createObjectURL(blob);
              blobUrlsToRevoke.push(url);
              return url;
            };

            const fontUrls = {
              name: createBlobUrl(fontBytesMap.name),
              label: createBlobUrl(fontBytesMap.label),
              amount: createBlobUrl(fontBytesMap.amount),
              cover: createBlobUrl(fontBytesMap.cover),
              pageInfo: createBlobUrl(fontBytesMap.pageInfo),
            };

            // ====================== 3. 构造最终 PDF 参数（层级清晰、合并集中） ======================
            const eventDateInfo = Utils.getEventDateInfo(app.currentEvent.startDateTime);
            const totalParts = app.gifts.length > CONFIG.PRINT_SPLIT_THRESHOLD ? Math.ceil(app.gifts.length / CONFIG.PRINT_SPLIT_THRESHOLD) : null;

            const baseOptions = {
              ...DEFAULT_PRINT_OPTIONS,
              ...(app.currentEvent.printOptions || {}),

              coverImage: coverImageUrl,
              title: app.currentEvent.name,
              recorder: app.currentEvent.recorder || null,
              subtitle: eventDateInfo.formattedDisplay,
              giftLabel: isSolemnTheme ? "礼金" : "贺礼",
              backgroundImage: bgImageUrl,
              backCoverImage: "./static/cover2.jpg",
              partIndex,
              totalParts,
              grandTotalAmount: app.totalAmountCache,
              grandTotalGivers: app.totalGiversCache,
              mainFontUrl: "./static/MaShanZheng-Regular.ttf",
              giftLabelFontUrl: "./static/SourceHanSerifCN-Heavy.ttf",
              formalFontUrl: "./static/NotoSansSCMedium-mini.ttf",
              itemsPerPage: app.getItemsPerPage(),
            };

            const generatorOptions = {
              ...baseOptions,
              giftBookStyles,
              // 自定义字体优先，没有则走默认静态字体
              mainFontUrl: fontUrls.name || baseOptions.mainFontUrl,
              giftLabelFontUrl: fontUrls.label || baseOptions.giftLabelFontUrl,
              formalFontUrl: fontUrls.pageInfo || baseOptions.formalFontUrl,
              amountFontUrl: fontUrls.amount || null,
              coverFontUrl: fontUrls.cover || null,
            };

            // ====================== 4. 生成 PDF ======================
            app.pdfGenerator = new GiftRegistryPDF(generatorOptions);

            const data = app.gifts.slice(startIndex, endIndex).map(({ data }) => ({
              name: data.name,
              amount: data.amount,
              type: data.type,
              remark: app.formatRemarkDisplay(data.remarkData) || null,
              abolished: !!data.abolished,
              amountText: Utils.amountToChinese(data.amount),
            }));

            const pdfBytes = await app.pdfGenerator.generate(data, generatorOptions);
            const blob = new Blob([pdfBytes], { type: "application/pdf" });
            const pdfUrl = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = pdfUrl;
            const safeEventName = (app.currentEvent.name || "礼簿").replace(/[\\/:*?"<>|]/g, "_");
            const dateStr = eventDateInfo.localeDate.replace(/\//g, "-");
            const partSuffix = partIndex ? `_Part${partIndex}` : "";
            link.download = `${safeEventName}_礼金记录_${dateStr}${partSuffix}.pdf`;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
          } catch (error) {
            console.error(error);
            app.ui.showNotification("生成 PDF 时出现错误，请重试。", "error");
          } finally {
            app.isGeneratingPdf = false;
            printBtn.disabled = false;
            printBtn.innerHTML = originalBtnText;
            blobUrlsToRevoke.forEach((url) => URL.revokeObjectURL(url));
          }
        }

        /**
         * 执行打印/生成导出 PDF (浏览器原生打印方式)
         */
        executePrint(startIdx, endIdx, partIndex = null, totalParts = null) {
          const app = this.app;
          // 确保数据已解密
          !this.allGiftsDecrypted && app.giftManager.decryptGiftsRange(startIdx, endIdx);
          const allGiftsSubset = app.gifts.slice(startIdx, endIdx);

          return new Promise(async (resolve) => {
            let printView = document.getElementById("print-view");
            if (printView) printView.remove();

            printView = document.createElement("div");
            printView.id = "print-view";
            printView.className = "absolute top-0 left-[-9999px]";

            const printOptions = {
              ...DEFAULT_PRINT_OPTIONS,
              ...(app.currentEvent.printOptions || {}),
            };
            const eventDateInfo = Utils.getEventDateInfo(app.currentEvent.startDateTime);

            document.title = `${app.currentEvent.name}礼金记录{partIndex ? "-P" + partIndex : ""}-${eventDateInfo.localeDate}`;

            // 封面页
            if (printOptions.printCover) {
              const coverPage = document.createElement("div");
              coverPage.className = "print-page print-cover-page";
              const formattedDate = eventDateInfo.formattedDisplay || "";
              coverPage.innerHTML = `
                  <div class="print-cover">
                      ${printOptions.showCoverTitle ? `<p>${app.currentEvent.name}</p><p>${formattedDate}</p>` : ""}
                      ${printOptions.showCoverTitle && partIndex ? `<p class="absolute top-[25mm] left-[30mm] !text-6xl">P${partIndex}</p>` : ""}
                  </div>
                `;
              printView.appendChild(coverPage);
            }

            // 内容页
            const giftsSubset = allGiftsSubset.filter((g) => g.data && !g.data.abolished);
            const totalGiftPages = Math.ceil(giftsSubset.length / app.getItemsPerPage()) || 1;

            for (let i = 0; i < totalGiftPages; i++) {
              const pageGifts = giftsSubset.slice(i * app.getItemsPerPage(), (i + 1) * app.getItemsPerPage());
              const pageContainer = document.createElement("div");
              pageContainer.className = "print-page"; // 自动应用背景图 CSS 变量
              const content = document.createElement("div");
              content.className = "print-book-content";
              this.renderGiftBookForPrint(content, pageGifts);
              pageContainer.appendChild(content);

              const pageSubtotal = pageGifts.reduce((sum, gift) => sum + (gift.data?.amount || 0), 0);
              const partInfo = partIndex ? `( P${partIndex}/P${totalParts} )` : "";

              pageContainer.innerHTML += `
                    <div class="print-footer">
                      <p>生成日期: ${new Date().toLocaleString("sv-SE")}</p>
                      <p class="print-page-number">第 ${i + 1} / ${totalGiftPages} 页 ${partInfo}</p>
                      <div class="print-footer-totals">
                        <span class="total-amount-print">本页小计: ${Utils.formatCurrency(pageSubtotal)}</span>
                      </div>
                    </div>`;
              printView.appendChild(pageContainer);
            }

            // 附录与统计
            printOptions.printAppendix && this.appendAppendixPages(printView, giftsSubset, partIndex, totalParts);
            printOptions.printSummary && this.appendSummaryPage(printView, giftsSubset, partIndex);

            // 封底页
            if (printOptions.printEndPage) {
              const afterPage = document.createElement("div");
              afterPage.className = "print-page print-cover-page";
              // 封底暂未做自定义变量，保持原样
              afterPage.innerHTML = `<div class="w-full h-full" style="background: url('./static/cover2.jpg') center/cover no-repeat;"></div>`;
              printView.appendChild(afterPage);
            }

            document.body.appendChild(printView);
            document.body.classList.add("printing");

            setTimeout(() => {
              window.print();
              setTimeout(() => {
                document.body.classList.remove("printing");
                if (printView) printView.remove();
                document.title = CONFIG.APP_NAME;
                resolve();
              }, 500);
            }, 1000);
          });
        }

        /**
         * 导出事项数据为 JSON（明文备份）
         */
        async exportEventAsJson() {
          const app = this.app;
          if (!app.currentEvent) return;

          try {
            const eventId = app.currentEvent.id;
            const rawGifts = await app.giftRepository.fetchGiftsByEvent(eventId);

            const decryptedGifts = rawGifts.map((gift) => {
              const decrypted = CryptoService.decrypt(gift.encryptedData, app.currentPassword);
              if (!decrypted) {
                throw new Error("decrypt_failed");
              }
              return {
                id: gift.id,
                eventId,
                guestLevelWeight: gift.guestLevelWeight ?? 0,
                levelUpdateTime: gift.levelUpdateTime ?? 0,
                ...decrypted,
              };
            });

            const safeEvent = { ...app.currentEvent };
            delete safeEvent.passwordHash;

            const payload = {
              version: 1,
              exportedAt: new Date().toISOString(),
              event: safeEvent,
              gifts: decryptedGifts,
            };

            const safeName = (app.currentEvent.name || "event").replace(/[\\/:*?"<>|]/g, "_");
            const timestamp = Utils.formatTimestampForFilename();
            const filename = `${safeName}_${timestamp}.json`;

            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            app.ui.showNotification("JSON 备份已导出。", "success");
          } catch (error) {
            console.error("导出 JSON 备份失败:", error);
            app.ui.showNotification("导出 JSON 文件失败，请重试。", "error");
          }
        }

        /**
         * 导出事项数据为二进制加密备份
         * 文件格式：[8字节文件头] + [AES 密文字节流]
         * 文件头结构：
         *   - 0-3: Magic Number "EGLB" (0x45 0x47 0x4C 0x42)
         *   - 4:   版本号 (0x01)
         *   - 5-7: 保留字节
         */
        async exportEventAsBinary() {
          const app = this.app;
          if (!app.currentEvent) return;

          try {
            // 定义文件格式常量
            const MAGIC_HEADER = [0x45, 0x47, 0x4c, 0x42]; // "EGLB"
            const FILE_VERSION = 0x01;
            const HEADER_LENGTH = 8;

            // 获取并处理礼金数据
            const eventId = app.currentEvent.id;
            const rawGifts = await app.giftRepository.fetchGiftsByEvent(eventId);

            const sanitizedGifts = rawGifts.map((gift) => {
              const decrypted = CryptoService.decrypt(gift.encryptedData, app.currentPassword);
              if (!decrypted) {
                throw new Error("decrypt_failed");
              }
              const encryptedData = CryptoService.encrypt(decrypted, app.currentPassword);
              return {
                encryptedData,
                guestLevelWeight: gift.guestLevelWeight ?? 0,
                levelUpdateTime: gift.levelUpdateTime ?? 0,
              };
            });

            // 准备导出数据（移除密码哈希）
            const safeEvent = { ...app.currentEvent };
            delete safeEvent.passwordHash;

            const payload = {
              version: 1,
              exportedAt: new Date().toISOString(),
              event: safeEvent,
              gifts: sanitizedGifts,
            };

            // 加密整个 payload
            const encryptedPayloadString = CryptoService.encrypt(JSON.stringify(payload), app.currentPassword);

            // 生成文件名
            const safeName = (app.currentEvent.name || "event").replace(/[\\/:*?"<>|]/g, "_");
            const timestamp = Utils.formatTimestampForFilename();
            const filename = `${safeName}_${timestamp}.bin`;

            // 构建文件头
            const header = new Uint8Array(HEADER_LENGTH);
            header.set(MAGIC_HEADER, 0); // 字节 0-3: Magic Number
            header[4] = FILE_VERSION; // 字节 4: 版本号
            header[5] = 0x00; // 字节 5-7: 保留
            header[6] = 0x00;
            header[7] = 0x00;

            // 将 Base64 密文转换为原始字节流
            const binaryString = atob(encryptedPayloadString);
            const payloadBytes = new Uint8Array(binaryString.length);
            for (let i = 0; i < binaryString.length; i++) {
              payloadBytes[i] = binaryString.charCodeAt(i);
            }

            // 组合文件头和数据体
            const finalBuffer = new Uint8Array(header.length + payloadBytes.length);
            finalBuffer.set(header, 0);
            finalBuffer.set(payloadBytes, header.length);

            // 创建 Blob 并下载
            const blob = new Blob([finalBuffer], { type: "application/octet-stream" });
            const url = URL.createObjectURL(blob);
            const link = document.createElement("a");
            link.href = url;
            link.download = filename;
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            URL.revokeObjectURL(url);

            app.ui.showNotification("加密备份已导出。", "success");
          } catch (error) {
            console.error("导出加密备份失败:", error);
            app.ui.showNotification("导出加密备份失败，请重试。", "error");
          }
        }

        /**
         * 从加密备份文件恢复事项数据
         * @param {File} file - 备份文件（必须是带文件头的二进制格式）
         */
        async importEventFromBinary(file) {
          const app = this.app;
          if (!app.currentEvent || !file) {
            app.ui.showNotification("请先选择要导入的备份文件。", "error");
            return;
          }

          // 在弹出其他验证弹窗之前缓存复选框状态，避免 DOM 被替换后读取失败
          const shouldClearOldData = !!document.getElementById("clear-old-data-on-import")?.checked;

          try {
            // 定义文件格式常量
            const MAGIC_HEADER = [0x45, 0x47, 0x4c, 0x42]; // "EGLB"
            const FILE_VERSION = 0x01;
            const HEADER_LENGTH = 8;

            // 步骤1：验证当前事项的管理密码
            const currentEventPassword = await app.requestAdminPassword("导入验证", "请输入当前事项的管理密码以继续。", app.currentEvent.passwordHash, true);
            if (currentEventPassword === null) return;

            // 步骤2：读取并验证文件格式
            const arrayBuffer = await file.arrayBuffer();
            const fileBytes = new Uint8Array(arrayBuffer);

            // 验证文件最小长度
            if (fileBytes.length < HEADER_LENGTH) {
              app.ui.showNotification("文件格式错误：文件过小。", "error");
              return;
            }

            // 验证 Magic Number
            if (fileBytes[0] !== MAGIC_HEADER[0] || fileBytes[1] !== MAGIC_HEADER[1] || fileBytes[2] !== MAGIC_HEADER[2] || fileBytes[3] !== MAGIC_HEADER[3]) {
              app.ui.showNotification("文件格式错误：不是有效的备份文件。", "error");
              return;
            }

            // 验证版本号
            const version = fileBytes[4];
            if (version > FILE_VERSION) {
              app.ui.showNotification(`文件版本 (v${version}) 过高，当前系统最高支持 v${FILE_VERSION}。`, "error");
              return;
            }

            // 步骤3：提取并解密数据（密文已为原始字节流）
            const payloadBytes = fileBytes.slice(HEADER_LENGTH);
            let binaryString = "";
            const chunkSize = 0x8000;
            for (let i = 0; i < payloadBytes.length; i += chunkSize) {
              const chunk = payloadBytes.subarray(i, i + chunkSize);
              binaryString += String.fromCharCode(...chunk);
            }
            const encryptedContent = btoa(binaryString);

            // 尝试用当前事项密码解密
            let decrypted = CryptoService.decrypt(encryptedContent, currentEventPassword);
            let finalPassword = currentEventPassword;

            // 如果解密失败，要求输入备份文件的密码
            if (!decrypted) {
              const backupPassword = await new Promise((resolve) => {
                const content = `
                        <p class="text-sm text-yellow-700 bg-yellow-50 p-3 rounded-md mb-3">
                          使用当前事项密码解密失败。备份文件可能使用了不同的密码。
                        </p>
                        <input type="password" id="backup-pwd-input"
                               class="w-full p-2 border rounded themed-ring"
                               placeholder="请输入备份文件的解密密码">
                      `;
                app.ui.showModal("输入解密密码", content, [
                  {
                    text: "取消",
                    class: "themed-button-secondary border px-4 py-2 rounded",
                    handler: () => resolve(null),
                  },
                  {
                    text: "确认",
                    class: "themed-button-primary px-4 py-2 rounded",
                    handler: () => {
                      const pwd = document.getElementById("backup-pwd-input").value;
                      resolve(pwd);
                    },
                  },
                ]);
                setTimeout(() => document.getElementById("backup-pwd-input")?.focus(), 50);
              });

              if (backupPassword === null) {
                app.ui.showNotification("已取消导入。", "info");
                return;
              }

              decrypted = CryptoService.decrypt(encryptedContent, backupPassword);
              finalPassword = backupPassword;

              if (!decrypted) {
                app.ui.showNotification("解密失败，密码错误或文件已损坏。", "error");
                return;
              }
            }

            // 步骤4：解析数据
            const payload = JSON.parse(decrypted);
            const giftRecords = Array.isArray(payload?.gifts) ? payload.gifts : [];

            // 步骤5：根据缓存的勾选状态决定是否清空旧数据
            if (shouldClearOldData) {
              const existingGifts = await app.giftRepository.fetchGiftsByEvent(app.currentEvent.id);
              for (const gift of existingGifts) {
                await app.giftRepository.deleteGift(gift.id);
              }
              app.ui.showNotification("旧数据已清空。", "info");
            }

            // 步骤6：导入礼金数据
            for (const record of giftRecords) {
              let encryptedData = record.encryptedData;
              if (!encryptedData && record.data) {
                encryptedData = CryptoService.encrypt(record.data, finalPassword);
              }
              if (!encryptedData) continue;

              await app.giftRepository.createGift({
                eventId: app.currentEvent.id,
                encryptedData,
                guestLevelWeight: record.guestLevelWeight ?? 0,
                levelUpdateTime: record.levelUpdateTime ?? 0,
              });
            }

            // 步骤7：更新事项信息
            const eventSnapshot = payload?.event || {};
            const mergedPrintOptions = {
              ...DEFAULT_PRINT_OPTIONS,
              ...(app.currentEvent.printOptions || {}),
              ...(eventSnapshot.printOptions || {}),
            };
            const updatedEvent = {
              ...app.currentEvent,
              ...eventSnapshot,
              id: app.currentEvent.id,
              passwordHash: app.currentEvent.passwordHash,
              printOptions: mergedPrintOptions,
            };
            await app.giftRepository.updateEvent(updatedEvent);
            app.currentEvent = updatedEvent;

            // 步骤8：刷新界面
            await app.giftManager.loadGiftsForCurrentEvent();
            app.session.save(app.currentEvent, app.currentPassword);

            app.ui.closeModal();
            app.ui.showNotification(`数据恢复成功，${shouldClearOldData ? "替换" : "追加"}了 ${giftRecords.length} 条记录。`, "success");
          } catch (error) {
            console.error("导入备份失败:", error);
            app.ui.showNotification("导入失败，文件格式可能无效或已损坏。", "error");
          }
        }
        /**
         * 显示备份/恢复弹窗，提供 JSON 与 BIN 导出或导入
         */
        showBackupRestoreModal() {
          const app = this.app;
          if (!app.currentEvent) return;

          const modalContent = `
                        <div class="space-y-5 text-left">
                          <div>
                            <p class="text-sm text-gray-600">可将当前事项数据备份为 JSON 或数据库（BIN）文件，亦可导入 BIN 文件进行恢复。</p>
                          </div>
                          <div class="grid sm:grid-cols-2 gap-3">
                            <button id="btn-backup-json" class="w-full themed-button-secondary border px-4 py-2 rounded">导出 JSON 数据</button>
                            <button id="btn-backup-bin" class="w-full themed-button-primary px-4 py-2 rounded">导出备份 (BIN)</button>
                          </div>
                          <div class="border-t pt-4 space-y-3">
                            <label class="block text-sm font-medium text-gray-700">导入备份文件</label>
                            <input type="file" id="backup-import-file" accept=".bin" class="w-full text-sm text-gray-600 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-gray-200 file:text-gray-700 hover:file:bg-gray-300" />
                            <div class="flex items-center mt-2">
                              <input type="checkbox" id="clear-old-data-on-import" class="h-4 w-4 themed-ring rounded border-gray-300">
                              <label for="clear-old-data-on-import" class="ml-2 block text-sm text-gray-800">导入前清空当前事项的所有旧数据</label>
                            </div>
                            <p class="text-xs text-gray-500 -mt-1">默认不勾选，即以追加方式导入新数据。</p>
                            <button id="btn-restore-backup" class="w-full themed-button-primary px-4 py-2 rounded">导入并恢复</button>
                            <p class="text-xs text-gray-500">导入时需输入当前事项的管理密码，请确保备份来源可靠。</p>
                          </div>
                        </div>
                      `;

          app.ui.showModal("备份 / 恢复数据", modalContent, [{ text: "关闭", class: "themed-button-secondary border px-4 py-2 rounded" }]);

          setTimeout(() => {
            const exportJsonBtn = document.getElementById("btn-backup-json");
            const exportBinBtn = document.getElementById("btn-backup-bin");
            const restoreBtn = document.getElementById("btn-restore-backup");
            const fileInput = document.getElementById("backup-import-file");

            if (exportJsonBtn) {
              exportJsonBtn.addEventListener("click", async () => {
                exportJsonBtn.disabled = true;
                await app.exportService.exportEventAsJson();
                exportJsonBtn.disabled = false;
              });
            }

            if (exportBinBtn) {
              exportBinBtn.addEventListener("click", async () => {
                exportBinBtn.disabled = true;
                await app.exportService.exportEventAsBinary();
                exportBinBtn.disabled = false;
              });
            }

            if (restoreBtn) {
              restoreBtn.addEventListener("click", async () => {
                if (!fileInput?.files?.length) {
                  app.ui.showNotification("请先选择要导入的备份文件。", "error");
                  return;
                }
                restoreBtn.disabled = true;
                await app.exportService.importEventFromBinary(fileInput.files[0]);
                restoreBtn.disabled = false;
              });
            }
          }, 50);
        }

        /**
         * 首次打印前提示用户确认引擎与记账人信息
         * 缓存结果以避免重复弹窗
         */
        async ensurePrintPreferences() {
          const app = this.app;
          if (!app.currentEvent) return false;
          const cacheKey = `printSetupShown_${app.currentEvent.id}`;
          if (sessionStorage.getItem(cacheKey)) return true;

          return new Promise((resolve) => {
            const isMobile = Utils.isMobile();
            const currentEngine = app.currentEvent.printOptions?.pdfEngine || "browser";
            const currentRecorder = app.currentEvent.recorder || "";
            const currentPrintOptions = {
              ...DEFAULT_PRINT_OPTIONS,
              ...(app.currentEvent.printOptions || {}),
            };
            const currentPrintEndPage = !!currentPrintOptions.printEndPage;

            const engineSelector = isMobile
              ? `<p class="text-sm text-gray-600 bg-red-50 border border-red-200 rounded p-3">检测到移动端环境，系统将自动使用 <strong>PDF-LIB</strong> 引擎导出。</p>`
              : `<div class="space-y-2">
                              <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="print-engine-select" value="browser" class="themed-text-radio themed-ring" ${currentEngine === "browser" ? "checked" : ""}>
                                <span class="text-sm">浏览器另存为PDF（文件小,不兼容移动端）</span>
                              </label>
                              <label class="flex items-center gap-2 cursor-pointer">
                                <input type="radio" name="print-engine-select" value="pdf-lib" class="themed-text-radio themed-ring" ${currentEngine === "pdf-lib" ? "checked" : ""}>
                                <span class="text-sm">PDF-LIB.JS引擎（文件稍大,兼容PC/移动端）</span>
                              </label>
                            </div>`;

            const modalContent = `
                        <div class="space-y-5 text-left">
                          <p class="text-sm text-gray-600">首次打印前建议补充关键信息，后续可在“设置事项”中继续修改。</p>
                          <div>
                            <label class="block text-sm font-medium text-gray-700 mb-1">记账人 <span class="text-xs text-red-400">(建议填写，非必填)</span></label>
                            <input id="print-first-recorder" type="text" class="w-full p-2 border rounded themed-ring" maxlength="30" value="${currentRecorder}" placeholder="示例：喻三">
                          </div>
                          <div>
                            <span class="block text-sm font-medium text-gray-700 mb-1">PDF渲染方式</span>
                            ${engineSelector}
                            <div class="mt-3 space-y-2">
                              <span class="block text-sm font-medium text-gray-700 mb-1">礼簿附页选项</span>
                              <div class="flex gap-2 text-sm flex-wrap text-gray-700">
                                <label class="flex items-center gap-2 text-sm text-gray-700">
                                  <input id="print-init-cover" type="checkbox" class="w-4 h-4 themed-ring rounded" ${currentPrintOptions.printCover ? "checked" : ""}>
                                  <span>封面</span>
                                </label>
                                <label class="flex items-center gap-2 text-sm text-gray-700">
                                  <input id="print-init-show-cover-title" type="checkbox" class="w-4 h-4 themed-ring rounded" ${currentPrintOptions.showCoverTitle ? "checked" : ""}>
                                  <span>封面标题</span>
                                </label>
                                <label class="flex items-center gap-2 text-sm text-gray-700">
                                  <input id="print-init-appendix" type="checkbox" class="w-4 h-4 themed-ring rounded" ${currentPrintOptions.printAppendix ? "checked" : ""}>
                                  <span>备注附录</span>
                                </label>
                                <label class="flex items-center gap-2 text-sm text-gray-700">
                                  <input id="print-init-summary" type="checkbox" class="w-4 h-4 themed-ring rounded" ${currentPrintOptions.printSummary ? "checked" : ""}>
                                  <span>总计页</span>
                                </label>
                                <label class="flex items-center gap-2 text-sm text-gray-700">
                                  <input id="print-init-end-page" type="checkbox" class="w-4 h-4 themed-ring rounded" ${currentPrintEndPage ? "checked" : ""}>
                                  <span>封底</span>
                                </label>
                              </div>
                            </div>
                            <p class="text-xs text-gray-400 mt-2">可在“设置事项”中再次调整。</p>
                          </div>
                        </div>
                      `;

            app.ui.showModal("打印初始化", modalContent, [
              {
                text: "取消",
                class: "themed-button-secondary border px-4 py-2 rounded",
                handler: () => resolve(false),
              },
              {
                text: "确认并继续",
                class: "themed-button-primary px-4 py-2 rounded",
                keepOpen: true,
                handler: async () => {
                  try {
                    const recorderInput = document.getElementById("print-first-recorder");
                    const recorderValue = recorderInput ? recorderInput.value.trim() : "";
                    const selectedEngine = isMobile ? "pdf-lib" : document.querySelector('input[name="print-engine-select"]:checked')?.value || "browser";

                    const printCoverInput = document.getElementById("print-init-cover");
                    const showCoverTitleInput = document.getElementById("print-init-show-cover-title");
                    const printAppendixInput = document.getElementById("print-init-appendix");
                    const printSummaryInput = document.getElementById("print-init-summary");
                    const printEndPageInput = document.getElementById("print-init-end-page");
                    const mergedPrintOptions = {
                      ...currentPrintOptions,
                      pdfEngine: selectedEngine,
                      printCover: printCoverInput ? printCoverInput.checked : currentPrintOptions.printCover,
                      showCoverTitle: showCoverTitleInput ? showCoverTitleInput.checked : currentPrintOptions.showCoverTitle,
                      printAppendix: printAppendixInput ? printAppendixInput.checked : currentPrintOptions.printAppendix,
                      printSummary: printSummaryInput ? printSummaryInput.checked : currentPrintOptions.printSummary,
                      printEndPage: printEndPageInput ? printEndPageInput.checked : currentPrintOptions.printEndPage,
                    };

                    const updatedEvent = {
                      ...app.currentEvent,
                      recorder: recorderValue,
                      printOptions: mergedPrintOptions,
                    };

                    await app.giftRepository.updateEvent(updatedEvent);
                    app.currentEvent = updatedEvent;
                    app.session.save(app.currentEvent, app.currentPassword);
                    sessionStorage.setItem(cacheKey, "true");
                    app.ui.closeModal();
                    resolve(true);
                  } catch (error) {
                    console.error("首次打印配置保存失败:", error);
                    app.ui.showNotification("保存打印配置失败，请重试。", "error");
                    resolve(false);
                  }
                },
              },
            ]);
          });
        }

        /**
         */
         createGiftBookRows(gifts, isPrint = false) {
          const app = this.app;
          const fragment = document.createDocumentFragment();
          const nameRow = document.createElement("div");
          nameRow.className = "gift-book-row";
          const typeRow = document.createElement("div");
          typeRow.className = "gift-book-row";
          const amountRow = document.createElement("div");
          amountRow.className = "gift-book-row";

          const typeText = app.currentEvent.theme === "theme-solemn" ? "礼金" : "贺礼";

          for (let i = 0; i < app.getItemsPerPage(); i++) {
            const gift = gifts[i];
            const giftIndex = isPrint ? null : (app.currentPage - 1) * app.getItemsPerPage() + i;

            // 姓名单元格
            const nameCell = document.createElement("div");
            nameCell.className = "book-cell name-cell";
            if (gift?.data) {
              const { nameHTML } = app.giftManager.generateGiftCellHTML(gift, giftIndex);
              nameCell.innerHTML = nameHTML;
              if (!isPrint) nameCell.dataset.giftIndex = giftIndex;
            }
            nameRow.appendChild(nameCell);

            // 贺礼/奠仪单元格
            const typeCell = document.createElement("div");
            typeCell.className = "book-cell type-cell";
            typeCell.textContent = typeText;
            typeRow.appendChild(typeCell);

            // 金额单元格
            const amountCell = document.createElement("div");
            amountCell.className = "book-cell amount-cell";
            if (gift?.data) {
              const { amountHTML } = app.giftManager.generateGiftCellHTML(gift, giftIndex);
              amountCell.innerHTML = amountHTML;
              if (!isPrint) amountCell.dataset.giftIndex = giftIndex;
            }
            amountRow.appendChild(amountCell);
          }

          fragment.append(nameRow, typeRow, amountRow);
          return fragment;
        }

        /**
         * 渲染打印用的礼簿内容
         * @param {HTMLElement} container - 打印 DOM 容器
         * @param {Array} gifts - 已过滤的礼金记录
         */
        renderGiftBookForPrint(container, gifts) {
          const app = this.app;
          container.innerHTML = "";
          container.appendChild(this.createGiftBookRows(gifts, true));
        }

        /**
         * 附加备注附录页（支持长文本分页）
         * @param {HTMLElement} printView - 打印视图根节点
         * @param {Array} gifts - 有效礼金记录
         * @param {number|null} partIndex - 分批编号
         * @param {number|null} totalParts - 总分批数
         */
        appendAppendixPages(printView, gifts, partIndex = null, totalParts = null) {
          const app = this.app;
          const giftsWithRemarks = gifts
            .map((g, idx) => {
              const recordIndex = idx + 1;
              const pageNumber = Math.ceil(recordIndex / app.getItemsPerPage());
              const positionInPage = ((recordIndex - 1) % app.getItemsPerPage()) + 1;
              return {
                ...g,
                indexLabel: `第${pageNumber}页第${positionInPage}人`,
              };
            })
            .filter((g) => g.data && app.hasRemarkData(g.data));

          if (giftsWithRemarks.length === 0) {
            return;
          }

          const ruler = document.createElement("div");
          ruler.style.cssText = `
                          position: absolute; top: -9999px; left: -9999px; visibility: hidden;
                          font-family: "KaiTi", "楷体", serif; font-weight: bold; letter-spacing: 2px;
                          word-break: break-word; padding: 8px; line-height: 2em; width: 103.14mm;
                        `;
          document.body.appendChild(ruler);

          try {
            const MAX_PAGE_CONTENT_HEIGHT_PX = 710;
            const TABLE_HEADER_HEIGHT_PX = 120;
            const ROW_BORDER_HEIGHT_PX = 4;
            const getRemarkCellHeight = (text) => {
              if (!text) text = " ";
              ruler.innerHTML = text.replace(/\n/g, "<br>").replace(/  /g, "&nbsp; ");
              return ruler.scrollHeight;
            };
            const findFittingText = (fullText, availableHeight) => {
              if (getRemarkCellHeight(fullText) <= availableHeight) {
                return [fullText, ""];
              }
              let low = 0,
                high = fullText.length,
                bestFitIndex = 0;
              while (low <= high) {
                let mid = Math.floor((low + high) / 2);
                if (getRemarkCellHeight(fullText.substring(0, mid)) <= availableHeight) {
                  bestFitIndex = mid;
                  low = mid + 1;
                } else {
                  high = mid - 1;
                }
              }
              let splitIndex = bestFitIndex;
              const breakChars = new Set([" ", ",", "，", ".", "。", ";", "；", "!", "！", "?", "？", "\n"]);
              for (let i = bestFitIndex - 1; i > bestFitIndex / 2; i--) {
                if (breakChars.has(fullText[i])) {
                  splitIndex = i + 1;
                  break;
                }
              }
              if (splitIndex === 0 && fullText.length > 0) {
                splitIndex = 1;
              }
              return [fullText.substring(0, splitIndex), fullText.substring(splitIndex)];
            };
            const pages = [];
            let currentPageItems = [];
            let remainingPageHeight = MAX_PAGE_CONTENT_HEIGHT_PX - TABLE_HEADER_HEIGHT_PX - 100;
            for (const gift of giftsWithRemarks) {
              let remainingRemarkText = app.formatRemarkDisplay(gift.data.remarkData || {}, " / ");
              let isFirstChunk = true;
              while (remainingRemarkText.length > 0) {
                if (remainingPageHeight <= 50 && currentPageItems.length > 0) {
                  pages.push(currentPageItems);
                  currentPageItems = [];
                  remainingPageHeight = MAX_PAGE_CONTENT_HEIGHT_PX - TABLE_HEADER_HEIGHT_PX;
                }
                const [textThatFits, textLeftOver] = findFittingText(remainingRemarkText, remainingPageHeight);
                if (textThatFits.length > 0) {
                  const chunkHeight = getRemarkCellHeight(textThatFits) + ROW_BORDER_HEIGHT_PX;
                  currentPageItems.push({ gift: gift, remarkText: textThatFits, isContinuation: !isFirstChunk });
                  remainingPageHeight -= chunkHeight;
                  isFirstChunk = false;
                }
                remainingRemarkText = textLeftOver;
                if (textLeftOver.length > 0) {
                  if (currentPageItems.length > 0) {
                    pages.push(currentPageItems);
                  }
                  currentPageItems = [];
                  remainingPageHeight = MAX_PAGE_CONTENT_HEIGHT_PX - TABLE_HEADER_HEIGHT_PX;
                }
              }
            }
            if (currentPageItems.length > 0) {
              pages.push(currentPageItems);
            }

            pages.forEach((pageItems, pageIndex) => {
              const appendixPage = document.createElement("div");
              appendixPage.className = "print-page";
              const tableRows = pageItems
                .map((item) => {
                  const nameCellContent = item.gift.data.name;
                  const indexCellContent = item.isContinuation ? " (续上)" : item.gift.indexLabel;
                  return `<tr><td>${nameCellContent}</td><td>${indexCellContent}</td><td class="text-left">${item.remarkText || "无"}</td></tr>`;
                })
                .join("");

              const partInfo = partIndex ? `P${partIndex}/P${totalParts}` : "";

              appendixPage.innerHTML = `
                            ${pageIndex === 0 ? '<h1 class="print-header">附录：宾客备注</h1>' : ""}
                            <table class="print-appendix-table text-lg" style="line-height: 2em;">
                              <thead><tr><th>姓名</th><th>记录位置</th><th>备注信息</th></tr></thead>
                              <tbody>${tableRows}</tbody>
                            </table>
                            <div class="print-footer">
                              <p>生成日期: ${new Date().toLocaleString("sv-SE")}</p>
                              <p class="print-page-number">备注附录 第 ${pageIndex + 1} / ${pages.length} 页</p>
                              <div class="print-footer-totals">${partInfo}</div>
                            </div>
                          `;
              printView.appendChild(appendixPage);
            });
          } finally {
            document.body.removeChild(ruler);
          }
        }

        /**
         * 附加统计总览页
         * @param {HTMLElement} printView - 打印视图根节点
         * @param {Array} gifts - 有效礼金记录（不含作废）
         * @param {number|null} partIndex - 分批编号
         */
        appendSummaryPage(printView, gifts, partIndex = null) {
          const app = this.app;
          if (gifts.length === 0) return;

          const stats = {
            现金: { count: 0, amount: 0 },
            支付宝: { count: 0, amount: 0 },
            微信: { count: 0, amount: 0 },
            其他: { count: 0, amount: 0 },
          };
          gifts.forEach((gift) => {
            const type = gift.data.type;
            if (stats[type]) {
              stats[type].count += 1;
              stats[type].amount += gift.data.amount;
            }
          });

          const eventDateInfo = Utils.getEventDateInfo(app.currentEvent.startDateTime);

          const partTotalCount = gifts.length;
          const partTotalAmount = gifts.reduce((sum, gift) => sum + gift.data.amount, 0);

          const tableRows = Object.entries(stats)
            .filter(([type, data]) => data.count > 0)
            .map(([type, data]) => `<tr><td>${type}</td><td>${data.count} 人</td><td>${Utils.formatCurrency(data.amount)}</td></tr>`)
            .join("");

          let totalRowsHtml = "";
          if (partIndex) {
            // 分批打印的场景
            totalRowsHtml = `
                        <tr class="themed-text">
                          <td>本部分总计</td>
                          <td>${partTotalCount} 人</td>
                          <td>${Utils.formatCurrency(partTotalAmount)}</td>
                        </tr>
                        <tr class="themed-text">
                          <td>事项总金额</td>
                          <td>${app.totalGiversCache} 人</td>
                          <td>${Utils.formatCurrency(app.totalAmountCache)}</td>
                        </tr>
                      `;
          } else {
            // 完整打印的场景
            totalRowsHtml = `
                        <tr>
                          <td>总计</td>
                          <td>${partTotalCount} 人</td>
                          <td>${Utils.formatCurrency(partTotalAmount)}</td>
                        </tr>
                      `;
          }

          const summaryPage = document.createElement("div");
          summaryPage.className = "print-page";
          summaryPage.innerHTML = `
                      <h1 class="print-header">总 计</h1>
                      <table class="print-appendix-table text-xl" style="line-height: 2em; margin-top: 20px;">
                        <thead>
                          <tr><th style="width: 20%;">送礼方式</th><th style="width: 20%;">人数</th><th>总金额</th></tr>
                        </thead>
                        <tbody>
                          ${tableRows}
                          ${totalRowsHtml}
                        </tbody>
                      </table>
                      <div class="w-[90%] mx-auto flex justify-end mt-20 pr-20">
                        <div class="text-center space-y-2 font-bold text-2xl">
                          ${app.currentEvent.recorder ? `<p>记账人:  ${app.currentEvent.recorder}</p>` : ""}
                          <p>${eventDateInfo.formattedDisplay}</p>
                        </div>
                      </div>`;
          printView.appendChild(summaryPage);
        }

        /**
         * 导出 Excel
         * 生成礼金明细及礼品清单（如有）
         */
        exportToExcel() {
          const app = this.app;
          if (app.gifts.length === 0) {
            app.ui.showNotification("没有可导出的数据。");
            return;
          }

          const formatHistoryToString = (historyArray) => {
            if (!historyArray || historyArray.length === 0) return "无修改记录";
            return [...historyArray]
              .reverse()
              .map((record, index) => {
                const recordTime = new Date(record.timestamp).toLocaleString("zh-CN");
                return `[${index + 1}] ${recordTime}: ${record.changeLog}`;
              })
              .join("\n");
          };

          const dataToExport = [];
          const giftSheetData = [];

          let totalAmount = 0;
          let activeCount = 0;
          let abolishedCount = 0;

          // 直接遍历已排序的 app.gifts 数组
          for (let i = 0; i < app.gifts.length; i++) {
            const g = app.gifts[i];
            const isAbolished = g.data.abolished === true;
            const guestLevel = g.data.guestLevel !== undefined ? g.data.guestLevel : 0;
            const guestLevelName = CONFIG.GUEST_LEVELS[guestLevel] || CONFIG.GUEST_LEVELS[0];

            // 备注处理 - 分别提取各个字段
            const remarkData = app.normalizeRemarkData(g.data.remarkData);
            const customRemark = remarkData.custom || "";
            const giftRemark = remarkData.gift || "";
            const relationRemark = remarkData.relation || "";
            const phoneRemark = remarkData.phone || "";
            const addressRemark = remarkData.address || "";

            // 如果记录有效（未作废）且礼品备注不为空，则添加到礼品清单
            if (!isAbolished && giftRemark) {
              giftSheetData.push({
                姓名: g.data.name,
                礼品名称: giftRemark,
                关系: relationRemark,
                登记时间: new Date(g.data.timestamp).toLocaleString("zh-CN"),
              });
            }

            dataToExport.push({
              姓名: g.data.name,
              金额: g.data.amount,
              收款类型: g.data.type,
              宾客等级: guestLevelName,
              备注: customRemark,
              礼品: giftRemark,
              关系: relationRemark,
              电话: phoneRemark,
              住址: addressRemark,
              状态: isAbolished ? "已作废" : "正常",
              作废理由: isAbolished ? g.data.abolishReason || "" : "",
              登记时间: new Date(g.data.timestamp).toLocaleString("zh-CN"),
              修改日志: formatHistoryToString(g.data.history),
            });

            if (isAbolished) {
              abolishedCount++;
            } else {
              activeCount++;
              totalAmount += g.data.amount;
            }
          }

          dataToExport.push({});
          dataToExport.push({
            姓名: "总计",
            金额: totalAmount,
            收款类型: `有效记录 ${activeCount} 条,作废 ${abolishedCount} 条,共 ${app.gifts.length} 条`,
          });

          const worksheet = XLSX.utils.json_to_sheet(dataToExport);

          // 调整列宽,为新增的列分配合适的宽度
          const columnWidths = [
            { wch: 10 }, // 姓名
            { wch: 12 }, // 金额
            { wch: 12 }, // 收款类型
            { wch: 10 }, // 宾客等级
            { wch: 30 }, // 备注(自定义)
            { wch: 20 }, // 礼品 (加宽一些)
            { wch: 15 }, // 关系
            { wch: 18 }, // 电话
            { wch: 25 }, // 住址
            { wch: 10 }, // 状态
            { wch: 30 }, // 作废理由
            { wch: 22 }, // 登记时间
            { wch: 60 }, // 修改日志
          ];
          worksheet["!cols"] = columnWidths;

          const workbook = XLSX.utils.book_new();
          XLSX.utils.book_append_sheet(workbook, worksheet, "礼金明细");

          if (giftSheetData.length > 0) {
            // 创建礼品清单的 worksheet
            const giftWorksheet = XLSX.utils.json_to_sheet(giftSheetData, {
              header: ["姓名", "礼品名称", "关系", "登记时间"], // 确保表头顺序
            });

            // 为礼品清单设置列宽
            giftWorksheet["!cols"] = [
              { wch: 10 }, // 姓名
              { wch: 30 }, // 礼品名称
              { wch: 18 }, // 关系
              { wch: 22 }, // 登记时间
            ];

            // 将新的 worksheet 附加到工作簿中，
            XLSX.utils.book_append_sheet(workbook, giftWorksheet, "礼品清单");
          }
          const eventDateInfo = Utils.getEventDateInfo(app.currentEvent.startDateTime);
          XLSX.writeFile(workbook, `${app.currentEvent.name}-礼金明细(${eventDateInfo.localeDate}).xlsx`);
          app.ui.showNotification("导出成功！", "success");
        }
      }
      class StatsService {
        /**
         */
        constructor(app) {
          this.app = app;
        }

        /**
         * 显示统计详情
         * 构建 GridJS 统计视图并提供筛选、导出能力
         */
        showStatistics() {
          const app = this.app;
          app.ui.elements.modal.classList.add("modal-large");

          if (app.statsAreDirty || !app.cachedStats) {
            const activeGifts = app.gifts.filter((g) => g.data && !g.data.abolished);
            const abolishedGifts = app.gifts.filter((g) => g.data && g.data.abolished);

            const stats = {
              totalAmount: 0,
              totalGivers: activeGifts.length,
              byType: { 现金: 0, 支付宝: 0, 微信: 0, 其他: 0 },
              abolishedCount: abolishedGifts.length,
              abolishedAmount: 0,
            };

            activeGifts.forEach(({ data }) => {
              if (data) {
                stats.totalAmount += data.amount;
                stats.byType[data.type] = (stats.byType[data.type] || 0) + data.amount;
              }
            });

            abolishedGifts.forEach(({ data }) => {
              if (data) {
                stats.abolishedAmount += data.amount;
              }
            });

            app.cachedStats = stats;
            app.statsAreDirty = false;
          }

          const stats = app.cachedStats;

          const statsHtml = `
                      <div class="grid grid-cols-1 md:grid-cols-4 gap-6">
                        <div id="grid-container" class="md:col-span-3 relative">
                          <!-- 筛选栏 -->
                          <div class="w-1/2 flex items-center gap-3 sm:absolute right-0 z-40">
                            <label class="text-sm font-medium text-gray-700 whitespace-nowrap">筛选条件：</label>
                            <select id="stats-filter-select" class="w-full p-3 border rounded-lg themed-ring pr-10">
                              <option value="all">全部记录</option>
                              <option value="max-amount">礼金最多</option>
                              <option value="min-amount">礼金最少</option>
                              <option value="has-remarks">有备注</option>
                              <option value="has-gifts">有礼品</option>
                              <option value="abolished">已作废</option>
                              <optgroup label="按收款方式筛选">
                                <option value="cash">筛选「现金」</option>
                                <option value="alipay">筛选「支付宝」</option>
                                <option value="wechat">筛选「微信」</option>
                                <option value="other">筛选「其他」</option>
                              </optgroup>
                            </select>
                          </div>
                          <!-- GridJS 表格容器 -->
                          <div id="grid-table-container"></div>
                        </div>
                        <div class="space-y-4">
                          <div class="flex justify-between p-3 bg-green-50  border-green-500 rounded-lg">
                            <span class="font-bold text-green-800">有效记录人数:</span>
                            <span class="font-bold text-green-600">${stats.totalGivers} 人</span>
                          </div>
                          <div class="flex justify-between p-3 bg-green-50  border-green-500 rounded-lg">
                            <span class="font-bold text-green-800">有效总金额:</span>
                            <span class="font-bold text-green-600">${Utils.formatCurrency(stats.totalAmount)}</span>
                          </div>
                          ${
                            stats.abolishedCount > 0
                              ? `
                            <div class="flex justify-between p-3 bg-red-50  border-red-500 rounded-lg">
                              <span class="font-bold text-red-800">作废记录:</span>
                              <span class="font-bold text-red-600">${stats.abolishedCount} 人</span>
                            </div>
                            <div class="flex justify-between p-3 bg-red-50  border-red-500 rounded-lg">
                              <span class="font-bold text-red-800">作废金额:</span>
                              <span class="font-bold text-red-600">${Utils.formatCurrency(stats.abolishedAmount)}</span>
                            </div>
                          `
                              : ""
                          }
                          <div class="border-t pt-4 mt-4">
                            <h4 class="font-semibold mb-2">按收款方式统计（有效记录）:</h4>
                            <ul class="space-y-2">${Object.entries(stats.byType)
                              .map(([type, amount]) => `<li class="flex justify-between"><span>${type}:</span> <span>${Utils.formatCurrency(amount)}</span></li>`)
                              .join("")}</ul>
                          </div>
                          <div class="border-t pt-4 mt-4">
                            <button id="export-excel-stats-btn" class="w-full themed-button-primary p-3 rounded-lg flex items-center justify-center gap-2">
                              <i class="ri-file-excel-line text-xl"></i>
                              <span>导出 Excel</span>
                            </button>
                          </div>
                        </div>
                      </div>`;

          app.ui.showModal("礼金统计详情", statsHtml, [{ text: "关闭", class: "themed-button-secondary border px-4 py-2 rounded" }]);

          setTimeout(() => {
            let currentFilteredGifts = [...app.gifts];
            let currentGrid = null;
            const renderGrid = (giftsToShow) => {
              const tableData = giftsToShow.map((g) => {
                const guestLevel = g.data.guestLevel !== undefined ? g.data.guestLevel : 0;
                const guestLevelName = CONFIG.GUEST_LEVELS[guestLevel] || CONFIG.GUEST_LEVELS[0];
                const remarkTextForTable = app.formatRemarkDisplay(g.data.remarkData || {}, " / ") || "无";
                return [
                  g.data.name,
                  g.data.amount,
                  remarkTextForTable, // 使用格式化方法
                  g.data.type,
                  new Date(g.data.timestamp).toLocaleString("zh-CN"),
                  g.data.abolished ? "已作废" : "正常",
                ];
              });

              const shouldPaginate = giftsToShow.length > CONFIG.PRINT_SPLIT_THRESHOLD;
              const gridConfig = {
                columns: ["姓名", "金额 (元)", "备注", "收款类型", "录入时间", "状态"],
                data: tableData,
                search: true,
                sort: true,
                fixedHeader: true,
                width: "100%",
                height: "62vh",
                language: {
                  search: { placeholder: "搜索..." },
                  pagination: { previous: "上一页", next: "下一页", showing: "显示", results: () => "条结果", to: "到", of: "共" },
                  loading: "加载中...",
                  noRecordsFound: "未找到匹配的记录",
                  error: "获取数据时发生错误",
                },
                style: {
                  th: { "background-color": "var(--primary-color)", color: "#fff" },
                  td: { cursor: "pointer" },
                },
              };

              if (shouldPaginate) {
                gridConfig.pagination = { enabled: true, limit: 50, summary: true };
              } else {
                gridConfig.pagination = false;
              }

              if (currentGrid) {
                try {
                  currentGrid.destroy();
                } catch (e) {}
              }
              const container = document.getElementById("grid-table-container");
              container.innerHTML = "";
              currentGrid = new gridjs.Grid(gridConfig);
              currentGrid.render(container);

              currentGrid.on("rowClick", (...args) => {
                const row = args.length > 1 ? args[1] : args[0];
                const clickedName = row.cells[0].data;
                const clickedTime = row.cells[5].data;

                const clickedGift = giftsToShow.find((g) => g.data.name === clickedName && new Date(g.data.timestamp).toLocaleString("zh-CN") === clickedTime);

                if (clickedGift) {
                  const giftIndex = app.gifts.findIndex((g) => g.id === clickedGift.id);
                  if (giftIndex !== -1) {
                    app.ui.closeModal();
                    setTimeout(() => app.showGiftDetails(giftIndex, { fromStats: true }), 150);
                  }
                }
              });
            };

            renderGrid(currentFilteredGifts);
            const filterSelect = document.getElementById("stats-filter-select");
            filterSelect.addEventListener("change", (event) => {
              const filterType = event.target.value;

              switch (filterType) {
                case "all":
                  currentFilteredGifts = [...app.gifts];
                  break;
                case "max-amount":
                  currentFilteredGifts = [...app.gifts].sort((a, b) => b.data.amount - a.data.amount);
                  break;
                case "min-amount":
                  currentFilteredGifts = [...app.gifts].sort((a, b) => a.data.amount - b.data.amount);
                  break;
                case "has-remarks":
                  currentFilteredGifts = app.gifts.filter((g) => app.hasRemarkData(g.data));
                  break;
                case "has-gifts":
                  currentFilteredGifts = app.gifts.filter((g) => {
                    const remark = app.normalizeRemarkData(g.data.remarkData);
                    return remark.gift && remark.gift.trim() !== "";
                  });
                  break;
                case "abolished":
                  currentFilteredGifts = app.gifts.filter((g) => g.data.abolished === true);
                  break;
                case "cash":
                  currentFilteredGifts = app.gifts.filter((g) => g.data && g.data.type === "现金");
                  break;
                case "alipay":
                  currentFilteredGifts = app.gifts.filter((g) => g.data && g.data.type === "支付宝");
                  break;
                case "wechat":
                  currentFilteredGifts = app.gifts.filter((g) => g.data && g.data.type === "微信");
                  break;
                case "other":
                  currentFilteredGifts = app.gifts.filter((g) => g.data && g.data.type === "其他");
                  break;
                default:
                  currentFilteredGifts = [...app.gifts];
              }

              renderGrid(currentFilteredGifts);
            });

            const exportBtn = document.getElementById("export-excel-stats-btn");
            if (exportBtn) {
              exportBtn.addEventListener("click", () => {
                app.exportService.exportToExcel();
              });
            }
          }, 100);
        }

        /**
         * 构建礼金记录历史时间线 HTML
         * @param {Array} history - 变更历史
         * @param {Object} currentGift - 当前礼金数据
         */
        generateTimelineHTML(history, currentGift) {
          const app = this.app;
          const reversedHistory = [...history].reverse();
          return `
                        <ul class="space-y-4 border-l-2 border-gray-300 ml-2">
                          <li class="relative pl-6 pb-4">
                            <div class="absolute w-3 h-3 bg-green-500 rounded-full -left-[7px] top-1 border-2 border-white"></div>
                            <div class="text-sm text-gray-500">当前状态 (${new Date(currentGift.timestamp).toLocaleString("zh-CN")})</div>
                          </li>
                          ${reversedHistory
                            .map(
                              (record, index) => `
                            <li class="relative pl-6 pb-4">
                              <div class="absolute w-3 h-3 bg-gray-400 rounded-full -left-[7px] top-1 border-2 border-white"></div>
                              <div class="text-sm text-gray-500">${new Date(record.timestamp).toLocaleString("zh-CN")}</div>
                              <div class="font-medium text-gray-800 mt-1">${record.changeLog}</div>
                              ${
                                index === reversedHistory.length - 1
                                  ? `<button class="btn-view-original mt-2 text-xs bg-gray-200 hover:bg-gray-300 px-2 py-1 rounded text-gray-700" data-history-index="0">查看最原始记录</button>`
                                  : `<button class="btn-view-snapshot mt-2 text-xs text-blue-500 hover:underline" data-history-index="${history.length - 1 - index}">查看此版本快照</button>`
                              }
                            </li>
                          `
                            )
                            .join("")}
                        </ul>
                      `;
        }
      }

      /**
       * 副屏服务
       */
      class GuestScreenService {
        /**
         */
        constructor(app) {
          this.app = app;
          this.guestWindow = null;
          this.isConnected = false;
          this.heartbeatInterval = null;
          this.MESSAGE_TYPES = {
            INIT: "guest_screen_init",
            UPDATE: "guest_screen_update",
            HEARTBEAT: "guest_screen_heartbeat",
            CONFIG: "guest_screen_config",
          };

          window.addEventListener("message", (e) => this.handleMessage(e));
        }

        /**
         */
        handleMessage(event) {
          if (event.data?.type === "guest_screen_ready") {
            this.isConnected = true;
            this.syncToGuestScreen();
            this.startHeartbeat();
          }
        }

        /**
         */
        open() {
          if (this.guestWindow && !this.guestWindow.closed) {
            this.guestWindow.focus();
            return;
          }

          const screenWidth = window.screen.availWidth;
          const screenHeight = window.screen.availHeight;

          this.guestWindow = window.open("./guest-screen.html", "GuestScreen", `width=${screenWidth},height=${screenHeight},left=0,top=0,location=no,menubar=no,toolbar=no`);

          if (this.guestWindow) {
            setTimeout(() => {
              if (this.guestWindow?.document.documentElement.requestFullscreen) {
                this.guestWindow.document.documentElement.requestFullscreen().catch(() => console.log("无法自动全屏"));
              }
            }, 500);
          }
        }

        /**
         */
        syncToGuestScreen() {
          if (!this.guestWindow || this.guestWindow.closed) {
            this.isConnected = false;
            this.stopHeartbeat();
            return;
          }

          const currentPageGifts = this.app.gifts.slice((this.app.currentPage - 1) * app.getItemsPerPage(), this.app.currentPage * app.getItemsPerPage());

          const activeGifts = currentPageGifts.filter((g) => g.data && !g.data.abolished);

          const message = {
            type: this.MESSAGE_TYPES.UPDATE,
            data: {
              eventName: this.app.currentEvent.name,
              theme: this.app.currentEvent.theme,
              currentPage: this.app.currentPage,
              gifts: activeGifts.map((g) => ({
                id: g.id,
                name: g.data.name,
                amount: g.data.amount,
                type: g.data.type,
                amountChinese: Utils.amountToChinese(g.data.amount),
              })),
              hidePrivacy: this.app.currentEvent.hidePrivacy || false,
              typeText: this.app.currentEvent.theme === "theme-solemn" ? "礼金" : "贺礼",
            },
            timestamp: Date.now(),
          };

          try {
            this.guestWindow.postMessage(message, "*");
          } catch (error) {
            console.error("发送消息到副屏失败:", error);
            this.isConnected = false;
          }
        }

        /**
         */
        startHeartbeat() {
          this.stopHeartbeat();
          this.heartbeatInterval = setInterval(() => {
            if (!this.guestWindow || this.guestWindow.closed) {
              this.isConnected = false;
              this.stopHeartbeat();
              return;
            }

            try {
              this.guestWindow.postMessage(
                {
                  type: this.MESSAGE_TYPES.HEARTBEAT,
                  timestamp: Date.now(),
                },
                "*"
              );
            } catch (error) {
              this.isConnected = false;
              this.stopHeartbeat();
            }
          }, 30000);
        }

        /**
         */
        stopHeartbeat() {
          if (this.heartbeatInterval) {
            clearInterval(this.heartbeatInterval);
            this.heartbeatInterval = null;
          }
        }

        /**
         */
        close() {
          this.stopHeartbeat();
          if (this.guestWindow && !this.guestWindow.closed) {
            this.guestWindow.close();
          }
          this.guestWindow = null;
          this.isConnected = false;
        }
      }

      /**
       * GiftBookApp 应用核心
       * - 管理生命周期、事件绑定与数据流转
       */
      class GiftBookApp {
        /**
         */
        constructor() {
          this.dbManager = new DBManager();
          this.giftRepository = new GiftRepository(this.dbManager);
          this.session = new SessionManager();
          this.passwordCache = new PasswordCache(CONFIG.PASSWORD_CACHE_DURATION);
          this.ui = new UIManager();
          this.giftManager = new GiftManager(this);
          this.exportService = new ExportService(this);
          this.statsService = new StatsService(this);
          this.guestScreenService = new GuestScreenService(this);

          this.currentEvent = null;
          this.currentPassword = null;
          this.gifts = [];
          this.currentPage = 1;
          this.isSpeechEnabled = true;
          this.totalAmountCache = 0;
          this.totalGiversCache = 0;
          this.cachedStats = null;
          this.statsAreDirty = true;
          this.selectedRemarkPresets = new Set();
          this.pdfGenerator = null;
          this.isGeneratingPdf = false;
          this.allGiftsDecrypted = false;
          this.REMARK_LABELS = [
            { key: "custom", label: "备注" },
            { key: "gift", label: "礼品" },
            { key: "relation", label: "关系" },
            { key: "phone", label: "电话" },
            { key: "address", label: "住址" },
          ];
        }

        /**
         * 应用初始化入口
         * 初始化数据库、绑定事件并尝试恢复上次会话
         */
        async init() {
          try {
            await this.dbManager.init();
            this.setupInitialUI();
            this.bindEvents();
            await this.tryRestoreSession();
          } catch (error) {
            console.error("应用初始化失败:", error);
            this.ui.showNotification("系统初始化失败，请刷新后重试。", "error");
          }
        }

        /**
         * 设置初始 UI 状态，例如默认时间与语音列表
         */
        setupInitialUI() {
          const { date, time } = Utils.getCurrentDateTime();
          this.ui.elements.startDateInput.value = date;
          this.ui.elements.startTimeInput.value = "00:00"; //time;
          this.ui.elements.endDateInput.value = date;
          this.ui.elements.endTimeInput.value = "23:59";
          this.populateVoiceList();
        }

        /**
         * 尝试恢复会话，如果成功则直接进入主界面
         */
        async tryRestoreSession() {
          const savedSession = this.session.load();
          if (!savedSession) {
            await this.loadEvents();
            this.ui.showScreen("setup");
            return;
          }

          try {
            const { event, encryptedPassword } = savedSession;
            const bytes = CryptoJS.AES.decrypt(encryptedPassword, event.passwordHash);
            const decryptedPassword = bytes.toString(CryptoJS.enc.Utf8);

            if (decryptedPassword) {
              this.currentEvent = event;
              this.currentPassword = decryptedPassword;
              await this.startSession();
            }
          } catch (error) {
            console.error("会话恢复失败", error);
            this.session.clear();
            await this.loadEvents();
            this.ui.showScreen("setup");
          }
        }

        /**
         * 加载所有事项到选择列表
         */
        async loadEvents() {
          const events = await this.giftRepository.fetchAllEvents();
          this.ui.elements.eventSelector.innerHTML = '<option value="">请选择一个事项</option>';

          if (events.length > 0) {
            this.ui.elements.selectEventSection.classList.remove("hidden");
            document.getElementById("or-text").classList.remove("hidden");
            events.forEach((event, index) => {
              const option = document.createElement("option");
              option.value = event.id;
              option.textContent = event.name;
              if (index === events.length - 1) {
                option.selected = true;
              }
              this.ui.elements.eventSelector.appendChild(option);
            });
          } else {
            this.ui.elements.selectEventSection.classList.add("hidden");
            document.getElementById("or-text").classList.add("hidden");
          }
        }

        /**
         * 启动事项会话，应用主题、加载礼金数据并展示主界面
         */
        async startSession() {
          this.ui.elements.currentEventTitleEl.textContent = this.currentEvent.name;
          this.ui.applyTheme(this.currentEvent.theme);

          this.applyCustomGiftBookStyle();

          this.currentEvent.printOptions = {
            ...DEFAULT_PRINT_OPTIONS,
            ...(this.currentEvent.printOptions || {}),
          };

          try {
            this.session.save(this.currentEvent, this.currentPassword);
          } catch (error) {
            console.error("会话存储失败", error);
          }

          // 检查事项是否结束，提醒用户导出数据
          const endTime = new Date(this.currentEvent.endDateTime);
          const now = new Date();

          if (now > endTime && !this.session.hasNotification(this.currentEvent.id)) {
            const title = "请及时导出数据";
            const message = `当前事项已结束，为确保数据安全，强烈建议您尽快通过【<strong>导出为 Excel</strong>】或【<strong>打印/另存为PDF</strong>】功能，将礼金数据完整备份至您的电脑或者微信。<br>
                             <span class="text-sm text-gray-600">原因：时间长了，存储空间可能会因浏览器清理、缓存清除等操作被重置，导致数据意外丢失。</span>`;

            setTimeout(() => {
              this.ui.showModal(title, message, [{ text: "我已知晓", class: "themed-button-primary px-4 py-2 rounded", role: "secondary" }]);
              this.session.markNotification(this.currentEvent.id);
            }, 500);
          }

          await this.giftManager.loadGiftsForCurrentEvent();
          this.ui.showScreen("main");
        }
        /**
         * 显示联系与支持作者弹窗
         */
        showAuthorSupportModal() {
          // 定义样式常量
          const containerClass = "flex flex-col md:flex-row gap-1 justify-center items-center py-4 px-2";
          const cardClass = "text-center flex-1 w-full flex flex-col items-center";
          const imgBoxClass = "w-48 h-48 bg-gray-50 border-2 border-dashed border-gray-300 rounded-xl flex items-center justify-center overflow-hidden mb-3 relative group transition-all hover:border-solid";
          const imgClass = "w-full h-full object-contain p-1";
          const wechatQrSrc = "./static/addme.jpg";
          const payQrSrc = "./static/support.jpg";

          const html = `
          <div class="${containerClass}">
            
            <div class="${cardClass}">
              <h4 class="font-bold text-lg text-gray-800 mb-1">联系作者</h4>
              <p class="text-md text-gray-500 mb-4">反馈、功能建议 · 交流</p>
              <div class="${imgBoxClass} hover:border-blue-400">
                <img src="${wechatQrSrc}" alt="微信二维码" class="${imgClass}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
                <div class="absolute inset-0 hidden items-center justify-center text-gray-400 bg-gray-50 text-sm">
                  此处放微信二维码<br>(请替换图片路径)
                </div>
              </div>
              <p class="text-sm font-medium text-gray-700 bg-gray-100 px-3 py-1 rounded-full mt-1">微信交流</p>
            </div>

            <div class="w-full h-px md:w-px md:h-64 bg-gray-200"></div>

            <div class="${cardClass}">
              <h4 class="font-bold text-lg text-gray-800 mb-1">扫码支持</h4>
              <p class="text-md text-gray-500 mb-4">开源不易，请作者喝杯奶茶</p>

              <div class="${imgBoxClass} hover:border-red-400">
                <img src="${payQrSrc}" alt="收款码" class="${imgClass}" onerror="this.style.display='none'; this.nextElementSibling.style.display='flex'">
                <div class="absolute inset-0 hidden items-center justify-center text-gray-400 bg-gray-50 text-sm">
                  此处放收款码<br>(请替换图片路径)
                </div>
              </div>
              <p class="text-sm font-medium text-red-600 bg-red-50 px-3 py-1 rounded-full mt-1">感谢您的鼓励与支持 ❤️</p>
            </div>

          </div>
          
          <div class="text-center mt-2 p-3 bg-yellow-50 rounded-lg text-xs text-yellow-700 border border-yellow-200">
            <i class="ri-information-line align-middle mr-1"></i>
            本程序为喻三编辑，如果您觉得这个系统对您有帮助，欢迎联系作。
          </div>
        `;
          this.ui.showModal("联系开发者", html, [{ text: "关闭", class: "themed-button-secondary border px-6 py-2 rounded-lg" }]);
        }
        /**
         * 绑定页面交互事件，负责表单、快捷键与辅助功能
         */
        bindEvents() {
          // 表单提交事件
          this.ui.elements.createEventForm.addEventListener("submit", (e) => this.handleCreateEvent(e));
          this.ui.elements.addGiftForm.addEventListener("submit", (e) => this.handleAddGift(e));
          this.ui.elements.unlockEventBtn.addEventListener("click", () => {
            const eventId = parseInt(this.ui.elements.eventSelector.value, 10);
            if (eventId) this.handleUnlockEvent(eventId);
            else this.ui.showNotification("请先选择一个事项。");
          });

          // 添加备注预设按钮的事件监听
          const presetButtons = document.querySelectorAll(".remark-preset-btn");
          presetButtons.forEach((btn) => {
            btn.addEventListener("click", (e) => {
              e.preventDefault();
              const preset = btn.dataset.preset;
              this.toggleRemarkPreset(preset, btn);
            });
          });
          // 分页按钮
          this.ui.elements.prevPageBtn.addEventListener("click", () => this.giftManager.changePage(-1));
          this.ui.elements.nextPageBtn.addEventListener("click", () => this.giftManager.changePage(1));

          // 功能按钮
          this.ui.elements.printBtn.addEventListener("click", () => this.exportService.prepareForPrint());
          this.ui.elements.exportExcelBtn.addEventListener("click", () => this.exportService.exportToExcel());
          this.ui.elements.statsBtn.addEventListener("click", () => this.statsService.showStatistics());
          this.ui.elements.searchIcon.addEventListener("click", () => this.handleSearch());
          this.ui.elements.searchNameInput.addEventListener("keyup", (e) => e.key === "Enter" && this.handleSearch());

          // 语音开关
          this.ui.elements.speechToggle.addEventListener("change", (e) => {
            this.isSpeechEnabled = e.target.checked;
          });

          // 礼簿点击事件
          this.ui.elements.giftBookContent.addEventListener("click", (e) => {
            const cell = e.target.closest("[data-gift-index]");
            if (!cell) return;
            const giftIndex = parseInt(cell.dataset.giftIndex, 10);
            if (isNaN(giftIndex)) return;

            if (cell.classList.contains("name-cell")) {
              this.showGiftDetails(giftIndex);
            } else if (cell.classList.contains("amount-cell") && this.gifts[giftIndex]) {
              const { name, amount } = this.gifts[giftIndex].data;
              this.speakGift(name, amount);
            }
          });

          // 事项下拉菜单
          this.ui.elements.eventSwitcherTrigger.addEventListener("click", (e) => {
            e.stopPropagation();
            const dropdown = this.ui.elements.eventDropdown;
            const isHidden = dropdown.classList.contains("hidden");
            if (isHidden) {
              dropdown.innerHTML = `
                            <a href="#" class="block px-4 py-2 text-sm themed-text font-semibold themed-link-hover" data-action="switch">切换/创建事项</a>
                            <a href="#" class="block px-4 py-2 text-sm themed-text font-semibold themed-link-hover" data-action="backup">备份/恢复数据</a>
                            <a href="#" class="block px-4 py-2 text-sm themed-text font-semibold themed-link-hover" data-action="guest-screen">进入副屏</a>
                            <a href="#" class="block px-4 py-2 text-sm themed-text font-semibold themed-link-hover" data-action="edit">设置此事项</a>
                            <a href="#" class="block px-4 py-2 text-sm themed-text font-semibold themed-link-hover" data-action="delete">删除此事项</a>`;
            }
            dropdown.classList.toggle("hidden");
          });

          this.ui.elements.eventDropdown.addEventListener("click", (e) => {
            e.preventDefault();
            const action = e.target.dataset.action;
            if (action) {
              this.ui.elements.eventDropdown.classList.add("hidden");
              switch (action) {
                case "switch":
                  this.showSetupScreen();
                  break;
                case "edit":
                  this.showEditEventInfoModal();
                  break;
                case "backup":
                  this.exportService.showBackupRestoreModal();
                  break;
                case "guest-screen":
                  this.openGuestScreen();
                  break;
                case "delete":
                  this.deleteCurrentEvent();
                  break;
              }
            }
          });

          // 跳页功能
          this.ui.elements.pageInfoEl.addEventListener("focusout", (e) => {
            if (e.target && e.target.id === "current-page-input") {
              this.handlePageInputChange(e);
            }
          });

          this.ui.elements.pageInfoEl.addEventListener("keydown", (e) => {
            if (e.target && e.target.id === "current-page-input" && e.key === "Enter") {
              e.preventDefault();
              this.handlePageInputChange(e);
              e.target.blur();
            }
          });

          // 全屏按钮
          this.ui.elements.fullscreenBtn.addEventListener("click", () => {
            if (!document.fullscreenElement) {
              document.documentElement.requestFullscreen();
            } else if (document.exitFullscreen) {
              document.exitFullscreen();
            }
          });
          this.ui.elements.supportBtn?.addEventListener("click", () => this.showAuthorSupportModal());
          document.addEventListener("fullscreenchange", () => {
            const isFullscreen = !!document.fullscreenElement;
            if (isFullscreen) {
              this.ui.elements.fullscreenIcon.classList.remove("ri-fullscreen-line");
              this.ui.elements.fullscreenIcon.classList.add("ri-fullscreen-exit-line");
            } else {
              this.ui.elements.fullscreenIcon.classList.remove("ri-fullscreen-exit-line");
              this.ui.elements.fullscreenIcon.classList.add("ri-fullscreen-line");
            }
          });

          // 语音预览
          this.ui.elements.previewCreateVoiceBtn.addEventListener("click", () => {
            this.previewSelectedVoice(this.ui.elements.eventVoiceSelect);
          });

          // 点击空白关闭下拉菜单
          window.addEventListener("click", () => this.ui.elements.eventDropdown.classList.add("hidden"));

          // 键盘快捷键
          document.addEventListener("keydown", (e) => {
            if (e.ctrlKey && e.key.toLowerCase() === "p") {
              e.preventDefault();
              this.exportService.prepareForPrint();
              return;
            }

            const isModalVisible = !this.ui.elements.modalContainer.classList.contains("hidden");
            const activeElement = document.activeElement;
            const isMainScreenVisible = !this.ui.elements.mainScreen.classList.contains("hidden");

            if (isModalVisible) {
              if (e.key === "Escape") {
                e.preventDefault();
                // 优先触发 secondary（通常为取消）
                this.ui.elements.modalActions.querySelector('button[data-role="secondary"]')?.click();
                return;
              }
              if (e.key === "Enter" && activeElement.tagName !== "TEXTAREA" && !activeElement.classList.contains("gridjs-input")) {
                e.preventDefault();
                // 始终触发 primary（确认）按钮，避免误触取消
                const primaryBtn = this.ui.elements.modalActions.querySelector('button[data-role="primary"]') || this.ui.elements.modalActions.querySelector("button:last-child");
                primaryBtn?.click();
                return;
              }
              return;
            }

            // 在主界面且不在输入框中时，支持方向键翻页
            if (isMainScreenVisible && activeElement.tagName !== "INPUT" && activeElement.tagName !== "TEXTAREA") {
              if (e.key === "ArrowLeft") {
                e.preventDefault();
                // 左箭头 = 上一页
                if (!this.ui.elements.prevPageBtn.disabled) {
                  this.giftManager.changePage(-1);
                }
                return;
              }
              if (e.key === "ArrowRight") {
                e.preventDefault();
                // 右箭头 = 下一页
                if (!this.ui.elements.nextPageBtn.disabled) {
                  this.giftManager.changePage(1);
                }
                return;
              }
            }

            if (e.key === "Enter" && isMainScreenVisible && activeElement.tagName !== "TEXTAREA") {
              const guestName = this.ui.elements.guestNameInput.value.trim();
              const giftAmount = this.ui.elements.giftAmountInput.value.trim();

              if (guestName && giftAmount) {
                e.preventDefault();
                this.ui.elements.addGiftForm.querySelector('button[type="submit"]')?.click();
              }
            }
          });
        }

        /**
         */
        handlePageInputChange(e) {
          const input = e.target;
          const newPage = parseInt(input.value, 10);
          const totalPages = Math.ceil(this.gifts.length / app.getItemsPerPage()) || 1;

          if (!isNaN(newPage) && newPage >= 1 && newPage <= totalPages && newPage !== this.currentPage) {
            this.currentPage = newPage;
            this.giftManager.ensureCurrentPageDecrypted();
            this.giftManager.render();
          } else {
            input.value = this.currentPage;
          }
        }

        /**
         * 根据事项 ID 校验管理员密码并进入会话
         */
        async handleUnlockEvent(eventId) {
          const event = await this.giftRepository.fetchEvent(eventId);
          if (!event) {
            this.ui.showNotification("未找到该事项。", "error");
            return;
          }

          // 使用统一的密码校验方法
          const password = await this.requestAdminPassword("输入管理密码", null, event.passwordHash, true);

          if (password === null) {
            // 用户取消
            return;
          }

          if (password) {
            this.currentEvent = event;
            this.currentPassword = password;
            await this.startSession();
          }
        }

        /**
         * 返回创建/选择事项界面并清除当前会话
         */
        showSetupScreen() {
          const previousEventId = this.currentEvent?.id;
          this.session.clear();
          this.currentEvent = null;
          this.currentPassword = null;
          this.gifts = [];
          if (previousEventId) {
            this.passwordCache.clear(previousEventId);
          }
          // 恢复创建表单的开始/结束默认时间
          this.setupInitialUI();
          this.ui.showScreen("setup");
          this.loadEvents();
        }

        /**
         * 创建新事项，包含表单校验与封面、打印配置处理
         */
        async handleCreateEvent(e) {
          e.preventDefault();
          const name = this.ui.elements.eventNameInput.value.trim();
          const startDateTime = `${this.ui.elements.startDateInput.value}T${this.ui.elements.startTimeInput.value}`;
          const endDateTime = `${this.ui.elements.endDateInput.value}T${this.ui.elements.endTimeInput.value}`;
          const password = this.ui.elements.adminPasswordInput.value;
          const theme = this.ui.elements.eventThemeSelect.value;
          const voiceName = this.ui.elements.eventVoiceSelect.value;
          const recorder = document.getElementById("event-recorder").value.trim();
          const pdfEngine = "browser";

          if (!name || !password || !startDateTime || !endDateTime) {
            this.ui.showNotification("请填写所有必填项。", "error");
            return;
          }

          if (new Date(startDateTime) >= new Date(endDateTime)) {
            this.ui.showNotification("开始时间必须早于结束时间。", "error");
            return;
          }

          let coverType = "default";
          // 弹窗二次验证刚输入的管理密码，防止记错
          const verifyContent = `
                        <div class="text-left">
                          <p class="mb-2">为确保管理密码输入无误，请再次输入以确认：</p>
                          <input type="password" id="verify-create-pwd" class="w-full p-2 border rounded themed-ring" placeholder="再次输入管理密码">
                          <p class="text-xs text-gray-500 mt-2">提示：两次密码需完全一致，才可以创建事项。</p>
                        </div>
                      `;

          this.ui.showModal("确认管理密码", verifyContent, [
            { text: "取消", class: "themed-button-secondary border px-4 py-2 rounded", role: "secondary" },
            {
              text: "确认创建",
              class: "themed-button-primary px-4 py-2 rounded",
              role: "primary",
              keepOpen: true,
              handler: async () => {
                const verifyPwd = document.getElementById("verify-create-pwd").value;
                if (verifyPwd !== password) {
                  this.ui.showNotification("两次输入的管理密码不一致，请重新确认", "error");
                  return;
                }

                const newEvent = {
                  name,
                  startDateTime,
                  endDateTime,
                  passwordHash: CryptoService.hash(password),
                  theme,
                  voiceName,
                  coverType: coverType,
                  recorder: recorder,
                  minSpeechAmount: 0,
                  coverType,
                  printOptions: {
                    ...DEFAULT_PRINT_OPTIONS,
                    pdfEngine,
                  },
                };

                try {
                  const newEventId = await this.giftRepository.createEvent(newEvent);
                  this.currentEvent = { ...newEvent, id: newEventId };
                  this.currentPassword = password;

                  this.ui.elements.createEventForm.reset();
                  this.ui.closeModal();
                  await this.startSession();
                  this.ui.showNotification("事项创建成功。", "success");
                } catch (error) {
                  this.ui.showNotification("创建事项失败，请重试。", "error");
                }
              },
            },
          ]);

          setTimeout(() => document.getElementById("verify-create-pwd")?.focus(), 50);
        }

        /**
         * 处理礼金录入表单提交
         * 验证输入并检查重复信息后给出确认提示
         */
        async handleAddGift(e) {
          e.preventDefault();
          const name = this.ui.elements.guestNameInput.value.trim();
          const amountStr = this.ui.elements.giftAmountInput.value;
          const type = document.querySelector('input[name="payment-type"]:checked')?.value;
          const remarkData = this.collectRemarkData();
          // 验证必填字段
          if (!name || !amountStr || !type) {
            this.ui.showNotification("信息不完整，请填写姓名、金额并选择收款类型。", "error");
            return;
          }

          // 验证金额有效性
          const amount = parseFloat(amountStr);
          if (isNaN(amount) || amount < 0) {
            this.ui.showNotification("金额无效，请输入非负金额。", "error");
            return;
          }

          if (type === "其他" && (!remarkData.custom || remarkData.custom.trim() === "")) {
            this.ui.showNotification("当收款类型为“其他”时，请在备注中说明具体情况。", "error");
            return; // 阻止提交
          }
          // 检查重复记录：同名或同名同金额
          const sameNameGifts = this.gifts.filter((g) => g.data?.name === name);
          const exactMatchExists = sameNameGifts.some((g) => g.data?.amount === amount);

          // 显示确认对话框（根据重复情况显示不同的警告级别）
          this.showGiftConfirmationModal(name, amount, remarkData, type, sameNameGifts.length > 0, exactMatchExists);
        }

        /**
         * 礼金录入确认弹窗
         * 根据重复情况展示提示并允许补充备注
         */
        showGiftConfirmationModal(name, amount, remarkData, type, nameExists, exactMatchExists) {
          let modalTitle, modalContent;
          this.ui.elements.giftAmountInput.blur();
          const remarkDisplay = this.formatRemarkDisplay(remarkData);

          // 生成备注输入框HTML（使用通用方法）
          const remarkInputsHTML = `
                          <label class="block text-sm font-medium text-gray-700">如非重复，建议填写备注(选填)</label>
                          <div class="space-y-2">
                            ${this.generateRemarkInputsHTML(remarkData)}
                          </div>
                      `;

          if (exactMatchExists) {
            modalTitle = "重复信息确认";
            modalContent = `
                          <div class="space-y-3 text-left">
                            <div class="p-3 bg-red-100 border-red-500 text-red-800 rounded-md">
                              <strong class="font-bold">警告：</strong>
                              <p class="text-sm">系统中已存在“相同姓名”且“相同金额”的记录，为避免重复录入，请仔细核对。</p>
                            </div>
                            <p><strong>来宾姓名:</strong> <span class="text-lg">${name}</span></p>
                            <p><strong>金额:</strong> <span class="font-bold text-xl themed-text">${Utils.formatCurrency(amount)}</span></p>
                            ${remarkInputsHTML}
                          </div>`;
          } else if (nameExists) {
            modalTitle = "同名信息确认";
            modalContent = `
                          <div class="space-y-3 text-left">
                            <div class="p-2 bg-yellow-100 text-yellow-800 rounded-md text-sm">
                              <strong>注意：</strong>系统中已存在名为 <strong>${name}</strong> 的记录。为避免混淆，建议您添加备注。
                            </div>
                            <p><strong>来宾姓名:</strong> <span class="text-lg">${name}</span></p>
                            <p><strong>金额:</strong> <span class="font-bold text-xl themed-text">${Utils.formatCurrency(amount)}</span></p>
                            ${remarkInputsHTML}
                          </div>`;
          } else {
            modalTitle = "请确认录入信息";
            modalContent = `
                          <div class="space-y-3 text-left">
                            <p><strong>来宾姓名:</strong> <span class="text-lg">${name}</span></p>
                            <p><strong>数字金额:</strong> <span class="font-bold text-xl themed-text">${Utils.formatCurrency(amount)}</span></p>
                            <p><strong>大写金额:</strong> <span class="font-bold text-xl themed-text">${Utils.amountToChinese(amount)}</span></p>
                            ${remarkDisplay ? `<p><strong>备注:</strong> ${remarkDisplay}</p>` : ""}
                          </div>`;
          }

          const confirmationHandler = () => {
            // 在同名或重复确认的情况下，收集更新后的备注数据
            const finalRemarkData = nameExists || exactMatchExists ? this.collectRemarkData(true) : remarkData;
            this.saveGift({ name, amount, type, remarkData: finalRemarkData });
          };

          this.ui.showModal(modalTitle, modalContent, [
            { text: "返回修改", class: "themed-button-secondary border px-4 py-2 rounded" },
            { text: "确认提交", class: "themed-button-primary px-4 py-2 rounded", handler: confirmationHandler, keepOpen: true },
          ]);
        }

        /**
         * 打开副屏窗口
         */
        openGuestScreen() {
          if (!this.currentEvent) {
            this.ui.showNotification("请先进入一个事项。", "error");
            return;
          }

          this.guestScreenService.open();
          this.ui.showNotification("副屏已打开，如未自动全屏请按 F11。", "info");
        }

        /**
         * 保存礼金记录
         * @param {Object} giftData - 礼金数据
         */
        async saveGift(giftData) {
          const isOutOfTime = new Date() < new Date(this.currentEvent.startDateTime) || new Date() > new Date(this.currentEvent.endDateTime);

          if (isOutOfTime) {
            const password = await this.requestAdminPassword("礼金补录", "当前已超出有效录入时间,请输入管理密码进行补录。", null, false);
            if (password === null) {
              this.ui.closeModal();
              return;
            }
          }

          try {
            // 默认等级为 0（雅宾）
            const guestLevel = giftData.guestLevel !== undefined ? giftData.guestLevel : 0;

            // timestamp 放入 encryptedData，用于显示创建/修改时间
            const fullGiftData = {
              ...giftData,
              timestamp: new Date().toISOString(),
              guestLevel,
            };
            const encryptedData = CryptoService.encrypt(fullGiftData, this.currentPassword);

            // levelUpdateTime 默认为 0（未修改过等级）
            const newGiftId = await this.giftRepository.createGift({
              eventId: this.currentEvent.id,
              encryptedData,
              guestLevelWeight: guestLevel,
              levelUpdateTime: 0, // 新增时为 0，表示未修改过等级
            });

            // 优化：直接插入新记录到内存，避免重新查询
            const newGift = {
              id: newGiftId,
              eventId: this.currentEvent.id,
              encryptedData,
              guestLevelWeight: guestLevel,
              levelUpdateTime: 0,
              data: fullGiftData,
              _needsDecrypt: false,
            };

            this.gifts.push(newGift);
            this.giftManager.sortGiftsByLevel();

            // 更新缓存
            this.giftManager.updateCacheOnAdd(giftData.amount);

            // 跳转到新记录所在页
            const newIndex = this.gifts.findIndex((g) => g.id === newGiftId);
            if (newIndex !== -1) {
              this.currentPage = Math.floor(newIndex / app.getItemsPerPage()) + 1;
            }

            this.ui.closeModal();
            this.ui.elements.addGiftForm.reset();
            document.querySelector('input[name="payment-type"][value="现金"]').checked = true;
            this.resetRemarkPresets();
            this.ui.elements.guestNameInput.focus();
            this.giftManager.render();
            this.speakGift(giftData.name, giftData.amount);
            this.ui.showNotification("录入成功！", "success");
            this.guestScreenService.syncToGuestScreen();
          } catch (error) {
            this.ui.closeModal();
            console.error("录入失败:", error);
            this.ui.showNotification("录入失败，请重试。", "error");
          }
        }

        /**
         * 姓名搜索
         * 支持同名筛选与快捷跳转详情
         */
        handleSearch() {
          const searchTerm = this.ui.elements.searchNameInput.value.trim();
          if (!searchTerm) {
            this.ui.showNotification("请输入姓名进行搜索。");
            return;
          }

          const results = [];
          for (let i = 0; i < this.gifts.length; i++) {
            // 确保解密后的 data 存在
            if (this.gifts[i].data?.name.includes(searchTerm)) {
              results.push({ ...this.gifts[i], originalIndex: i });
            }
          }
          this.ui.elements.searchNameInput.blur();

          if (results.length === 0) {
            this.ui.showNotification(`没有找到姓名为 \"${searchTerm}\" 的记录`);
            return;
          }

          const resultsHtml = results
            .map((r) => {
              const giftData = r.data;
              const remarkText = this.formatRemarkDisplay(giftData.remarkData || null);

              // 只有当 remarkText 有内容时，才生成备注的HTML
              const remarkHtml = remarkText ? `<p class="text-sm text-red-500 mt-1"><strong>备注:</strong> ${remarkText}</p>` : "";

              return `
                        <div class="p-3 border-b flex justify-between items-center">
                          <div>
                            <p><strong>姓名:</strong> ${giftData.name}</p>
                            <p><strong>金额:</strong> ${giftData.amount.toFixed(2)} 元 (${giftData.type})</p>
                            ${remarkHtml}
                          </div>
                          <button class="view-details-btn themed-button-primary px-3 py-1 rounded" data-gift-index="${r.originalIndex}">查看详情</button>
                        </div>
                      `;
            })
            .join("");

          this.ui.showModal(`"${searchTerm}" 的搜索结果`, `<div class="max-h-80 overflow-y-auto">${resultsHtml}</div>`, [{ text: "关闭", class: "themed-button-secondary border px-4 py-2 rounded" }]);

          setTimeout(() => {
            document.querySelectorAll(".view-details-btn").forEach((btn) => {
              btn.onclick = () => {
                const giftIndex = parseInt(btn.dataset.giftIndex, 10);
                this.ui.closeModal();
                setTimeout(() => this.showGiftDetails(giftIndex), 150);
              };
            });
          }, 50);
        }

        /**
         * 展示礼金详情弹窗，并绑定详情区域操作按钮
         * @param {number} giftIndex - 当前礼金在 this.gifts 中的下标
         * @param {Object} options - 额外配置
         * @param {boolean} options.fromStats - 是否来自统计页（隐藏返回按钮）
         *
         * 核心职责：
         * - 渲染礼金基础信息、嘉宾等级、备注详情
         * - 控制纠错、修改金额、备注、撤销等入口
         * - 在存在历史记录时拼装时间线并支持快照查看
         */
        showGiftDetails(giftIndex, options = {}) {
          const { fromStats = false } = options;
          const gift = this.gifts[giftIndex];
          if (!gift || !gift.data) return;

          const g = gift.data;
          const hasHistory = g.history && g.history.length > 0;
          const isAbolished = g.abolished === true;
          const nameCorrectionCount = countNameCorrections(g.history);
          const remainingNameCorrections = Math.max(0, 2 - nameCorrectionCount);
          const canCorrectName = !isAbolished && remainingNameCorrections > 0;
          const amountCorrectionCount = countAmountCorrections(g.history);
          const remainingAmountCorrections = Math.max(0, 1 - amountCorrectionCount);
          const canModifyAmount = !isAbolished && remainingAmountCorrections > 0;

          // 生成嘉宾等级选项（使得嘉宾等级高的排在前面）
          const guestLevel = g.guestLevel !== undefined ? g.guestLevel : 0;
          const levelOptions = CONFIG.GUEST_LEVELS.map((levelName, index) => ({ levelName, index }))
            .reverse() // 反转数组，得等级高的排前面
            .map(({ levelName, index }) => `<option value="${index}" ${index === guestLevel ? "selected" : ""}>${levelName}</option>`)
            .join("");

          // 根据剩余纠错/修改次数控制按钮是否可用及提示文案
          const correctNameButtonHtml = !isAbolished
            ? `<button id="btn-correct-name" data-remaining-corrections="${remainingNameCorrections}" class="text-sm text-blue-600 hover:underline px-2 py-1 ${canCorrectName ? "" : "opacity-50 cursor-not-allowed"}" ${
                canCorrectName ? "" : 'disabled data-fixed-disabled="true" title="姓名纠错次数已达上限"'
              }>纠错</button>`
            : "";
          const modifyAmountButtonHtml = !isAbolished
            ? `<button id="btn-modify-amount" data-remaining-amount-corrections="${remainingAmountCorrections}" class="text-sm text-blue-600 hover:underline px-2 py-1 ${
                canModifyAmount ? "" : "opacity-50 cursor-not-allowed"
              }" ${canModifyAmount ? "" : 'disabled data-fixed-disabled="true" title="金额已修改，无法再次调整"'}>修改</button>`
            : "";
          const detailsHtml = `
                      <div class="space-y-4 text-left h-full flex flex-col" id="current-details-container" data-gift-index="${giftIndex}">
                        <div class="flex justify-between items-center border-b pb-2 mb-2">
                          <h4 class="font-bold text-lg">当前记录信息</h4>
                        </div>
                        ${
                          isAbolished
                            ? `
                          <div class="p-3 bg-red-50  border-red-500 text-red-800 rounded">
                            <p class="font-bold flex items-center"><i class="ri-error-warning-line mr-2"></i>此记录已作废。</p>
                            <p class="text-sm mt-1"><strong>作废理由：</strong>${g.abolishReason || "无"}</p>
                            <p class="text-xs text-gray-600 mt-1">作废时间：${new Date(g.abolishTime).toLocaleString("zh-CN")}</p>
                          </div>
                        `
                            : ""
                        }

                        <div id="name-display-area" class="flex justify-between items-center p-2 hover:bg-gray-50 rounded ${isAbolished ? "opacity-60" : ""}">
                          <div class="flex items-center gap-3 flex-wrap">
                            <div><strong>姓名:</strong> <span class="text-lg ml-2">${g.name}</span></div>
                            ${
                              !isAbolished
                                ? `
                              <div class="flex items-center gap-2">
                                <select id="guest-level-select" class="text-sm px-3 py-1.5 border border-gray-300 rounded-md bg-white themed-ring cursor-pointer">
                                  ${levelOptions}
                                </select>
                              </div>
                            `
                                : ""
                            }
                          </div>
                          ${correctNameButtonHtml}
                        </div>

                        <div id="amount-display-area" class="flex justify-between items-center p-2 hover:bg-gray-50 rounded ${isAbolished ? "opacity-60" : ""}">
                          <div>
                            <p><strong>金额:</strong> <span class="font-bold themed-text text-lg ml-2 ${isAbolished ? "line-through" : ""}">${Utils.formatCurrency(g.amount)}</span></p>
                            <p class="text-sm text-gray-500 mt-1"><strong>类型:</strong> ${g.type}</p>
                          </div>
                          ${modifyAmountButtonHtml}
                        </div>

                        <div id="remarks-display-area" class="p-2 hover:bg-gray-50 rounded ${isAbolished ? "opacity-60" : ""}">
                          <div class="flex justify-between items-start">
                            <strong>备注:</strong>
                            ${!isAbolished ? '<button id="btn-edit-remarks" class="text-sm text-blue-600 hover:underline px-2 py-1">修改</button>' : ""}
                          </div>
                          <div class="mt-1 text-gray-700 space-y-1">
                            ${this.formatRemarkDetailsDisplay(g.remarkData)}
                          </div>
                        </div>

                        <div class="text-sm text-gray-400 border-t pt-2 mt-auto">
                          录入/修改时间: ${new Date(g.timestamp).toLocaleString("zh-CN")}
                        </div>
                      </div>`;

          let modalContent = "";
          if (hasHistory) {
            this.ui.elements.modal.classList.add("modal-large");
            const timelineHtml = this.statsService.generateTimelineHTML(g.history, g);
            modalContent = `
                        <div class="grid grid-cols-1 md:grid-cols-6 gap-6 h-[60vh]">
                          <div class="md:col-span-3 border-r pr-4 overflow-y-auto">${detailsHtml}</div>
                          <div class="md:col-span-3 pl-2 bg-gray-50 rounded-lg p-4">
                            <h4 class="font-bold text-lg border-b pb-2 mb-4 flex justify-between items-center">
                              <span>历史修改痕迹</span>
                            </h4>
                            ${timelineHtml}
                          </div>
                        </div>`;
          } else {
            this.ui.elements.modal.classList.remove("modal-large");
            modalContent = detailsHtml;
          }

          // 确保模态按钮可见
          this.ui.elements.modalActions.classList.remove("hidden");

          // 根据来源决定按钮文字和行为
          const modalButtons = fromStats
            ? [
                {
                  text: "返回统计",
                  class: "themed-button-secondary border px-4 py-2 rounded",
                  handler: () => this.statsService.showStatistics(),
                  keepOpen: true,
                },
              ]
            : [
                { text: '<i class="ri-delete-bin-line mr-1"></i>作废此记录', class: "themed-button-secondary border px-4 py-2 rounded mr-auto", handler: () => this.giftManager.abolishGift(giftIndex), keepOpen: true },
                { text: "关闭", class: "themed-button-secondary border px-4 py-2 rounded" },
              ];

          this.ui.showModal(`${g.name} 的礼金详情 ${hasHistory ? '<p class="text-sm text-orange-600 font-normal">（警告：此宾客数据存在修改，请自行验证数据真实性！）</p>' : ""}`, modalContent, modalButtons);

          // 绑定编辑和作废按钮事件
          setTimeout(() => {
            const btnCorrectName = document.getElementById("btn-correct-name");
            const btnModifyAmount = document.getElementById("btn-modify-amount");
            const btnEditRemarks = document.getElementById("btn-edit-remarks");
            const levelSelect = document.getElementById("guest-level-select");

            if (btnCorrectName && !btnCorrectName.disabled) btnCorrectName.onclick = () => this.enableInlineEdit(giftIndex, "name");
            if (btnModifyAmount && !btnModifyAmount.disabled) btnModifyAmount.onclick = () => this.enableInlineEdit(giftIndex, "amount");
            if (btnEditRemarks) btnEditRemarks.onclick = () => this.enableInlineEdit(giftIndex, "remarks");

            // 绑定宾客等级选择器变化事件
            if (levelSelect) {
              levelSelect.addEventListener("change", async (e) => {
                const newLevel = parseInt(e.target.value, 10);
                const oldLevel = g.guestLevel !== undefined ? g.guestLevel : 0;
                if (newLevel !== oldLevel) {
                  const oldLevelName = CONFIG.GUEST_LEVELS[oldLevel];
                  const newLevelName = CONFIG.GUEST_LEVELS[newLevel];

                  // 需要验证密码，但支持N分钟免密
                  const password = await this.requestAdminPassword("修改宾客等级", `即将把 "${g.name}" 从 "${oldLevelName}" 修改为 "${newLevelName}"`, null);

                  if (password === null) {
                    // 用户取消，恢复原来的值
                    e.target.value = oldLevel;
                    return;
                  }

                  // 更新宾客等级
                  await this.updateGuestLevel(giftIndex, newLevel, oldLevel);
                }
              });
            }

            if (hasHistory) {
              this.bindViewOriginalEvents(g.history, giftIndex);
            }
          }, 50);
        }

        /**
         * 礼簿样式设置
         */
        async showGiftBookStyleModal() {
          if (Utils.isMobile()) {
            this.ui.showNotification("移动端请使用默认样式", "info");
            return;
          }

          const isSolemn = this.currentEvent.theme === "theme-solemn";

          // 定义默认样式值
          const getDefaults = () => {
            return {
              name: { size: 20, color: "#333333", font: "" },
              type: { size: 20, color: isSolemn ? "#374151" : "#cc0000", font: "" },
              amountChinese: { size: 20, color: "#333333", font: "" },
              coverText: { size: 30, color: "#f5d4ab", font: "" },
              pageInfo: {
                themeColor: isSolemn ? "#1f2937" : "#b91c1c",
                baseColor: isSolemn ? "#1f2937" : "#1f2937",
                font: "",
              },
            };
          };

          const style = this.currentEvent.customStyle || {};
          const localFonts = style.localFonts || [];
          const defaults = getDefaults();

          // 获取当前图片 URL
          const bgUrl = await ImageCache.getBackgroundUrl(this.currentEvent.id);
          let currentCoverUrl = "";
          if (this.currentEvent.coverType === "custom") {
            currentCoverUrl = await ImageCache.getEventCoverUrl(this.currentEvent.id);
          }

          const printOptions = {
            ...DEFAULT_PRINT_OPTIONS,
            ...(this.currentEvent.printOptions || {}),
          };

          // === 4. 构建文字样式 HTML (使用配置数组) ===
          const fieldConfigs = [
            { key: "name", label: "礼簿页姓名", type: "std" },
            { key: "type", label: "礼簿页标签 (礼金/贺礼)", type: "std" },
            { key: "amountChinese", label: "礼簿页（大写金额）", type: "std" },
            { key: "coverText", label: "封面页标题", type: "std" },
            { key: "pageInfo", label: "基础样式", type: "print-special" }, // 特殊类型
          ];

          const textStyleHtml = fieldConfigs
            .map((config) => {
              const field = config.key;
              const custom = style[field] || {};
              const def = defaults[field];

              // 构建字体下拉框
              const displayFont = custom.font || "";
              const fontOptions = localFonts
                .map(
                  (f) =>
                    `<option value="${f.postscriptName}" style="font-family: '${f.family}', sans-serif;" ${f.postscriptName === displayFont ? "selected" : ""}>
                          ${f.fullName || f.family}
                      </option>`
                )
                .join("");
              const fontSelectHtml = `
                    <div class="flex items-center">
                      <label class="block font-medium text-gray-500 mr-1 whitespace-nowrap">字体</label>
                      <select data-field="${field}" data-prop="font"
                              class="flex-1 w-full p-2 border border-gray-300 rounded themed-ring text-sm bg-white text-gray-700"
                              ${localFonts.length === 0 ? "disabled" : ""}>
                        <option value="">系统默认字体</option>
                        ${fontOptions}
                      </select>
                    </div>`;

              // 根据类型生成不同的输入控件
              let inputsHtml = "";

              if (config.type === "print-special") {
                // pageInfo 特殊布局：主题色 + 基础字色 + 字体
                const displayThemeColor = custom.themeColor || def.themeColor;
                const displayBaseColor = custom.baseColor || def.baseColor;
                inputsHtml = `
                      <!-- 主题色 (边框/页头) -->
                      <div class="flex items-center">
                          <label class="block font-medium text-gray-500 mr-1 whitespace-nowrap">主题色</label>
                          <div class="flex flex-1 items-center w-full border border-gray-300 rounded overflow-hidden h-[38px] relative">
                              <input type="color" data-field="${field}" data-prop="themeColor" value="${displayThemeColor}"
                                  class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                              <div class="color-preview w-8 h-full border-r border-gray-200" style="background-color: ${displayThemeColor}"></div>
                              <span class="color-text flex-1 text-center text-sm text-gray-600 font-mono bg-white h-full leading-[38px]">
                                  ${displayThemeColor}
                              </span>
                          </div>
                      </div>
                      <!-- 基础字色 (页脚/内容) -->
                      <div class="flex items-center">
                          <label class="block font-medium text-gray-500 mr-1 whitespace-nowrap">基础字色</label>
                          <div class="flex flex-1 items-center w-full border border-gray-300 rounded overflow-hidden h-[38px] relative">
                              <input type="color" data-field="${field}" data-prop="baseColor" value="${displayBaseColor}"
                                  class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                              <div class="color-preview w-8 h-full border-r border-gray-200" style="background-color: ${displayBaseColor}"></div>
                              <span class="color-text flex-1 text-center text-sm text-gray-600 font-mono bg-white h-full leading-[38px]">
                                  ${displayBaseColor}
                              </span>
                          </div>
                      </div>
                      ${fontSelectHtml}
                   `;
              } else {
                // 标准布局：字号 + 颜色 + 字体
                const displaySize = custom.size || def.size;
                const displayColor = custom.color || def.color;

                inputsHtml = `
                      <!-- 字号 -->
                      <div class="flex items-center">
                          <label class="block font-medium text-gray-500 mr-1 whitespace-nowrap">字号 (px)</label>
                          <input type="number" data-field="${field}" data-prop="size" value="${displaySize}"
                              class="flex-1 w-full p-2 border border-gray-300 rounded themed-ring text-center font-bold text-gray-700 bg-gray-50 focus:bg-white">
                      </div>
                      <!-- 颜色 -->
                      <div class="flex items-center">
                          <label class="block font-medium text-gray-500 mr-1 whitespace-nowrap">颜色</label>
                          <div class="flex flex-1 items-center w-full border border-gray-300 rounded overflow-hidden h-[38px] relative">
                              <input type="color" data-field="${field}" data-prop="color" value="${displayColor}"
                                  class="absolute inset-0 w-full h-full opacity-0 cursor-pointer z-10">
                              <div class="color-preview w-8 h-full border-r border-gray-200" style="background-color: ${displayColor}"></div>
                              <span class="color-text flex-1 text-center text-sm text-gray-600 font-mono bg-white h-full leading-[38px]">
                                  ${displayColor}
                              </span>
                          </div>
                      </div>
                      ${fontSelectHtml}
                   `;
              }

              return `
                <div class="p-4 border rounded-lg bg-white shadow-sm flex flex-col h-full">
                  <h4 class="font-bold text-gray-800 mb-3 text-center pb-2 border-b border-gray-100 text-sm">${config.label}</h4>
                  <div class="space-y-3 flex-1">
                    ${inputsHtml}
                  </div>
                </div>`;
            })
            .join("");

          // === HTML 构建 ===
          // 统一 ID 命名规范： style-cover-* 和 style-bg-*
          const content = `
              <div class="space-y-6 text-left max-h-[75vh] pr-1">

                <!-- 第一部分：图片资源 (封面 & 背景) -->
                <div class="p-3 rounded border border-gray-200">
                  <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                      <!-- 封面图部分 -->
                      <div>
                          <div class="flex items-center justify-between mb-2">
                              <div class="flex items-center gap-3">
                                  <label class="block text-sm font-bold text-gray-700">礼簿封面图</label>
                                  <!-- 切换开关 -->
                                  <label class="relative h-5 w-16 cursor-pointer">
                                      <input type="checkbox" id="style-cover-toggle" class="sr-only peer" ${this.currentEvent.coverType === "custom" ? "checked" : ""}>
                                      <div class="h-full w-full rounded-full bg-gray-300 transition-colors duration-300 peer-checked:bg-[var(--button-bg-color)]"></div>
                                      <span class="absolute right-4 top-1/2 -translate-y-1/2 text-[10px] font-bold transition-opacity duration-300 peer-checked:opacity-0">默认</span>
                                      <span class="absolute left-2 top-1/2 -translate-y-1/2 text-[10px] font-bold text-white opacity-0 transition-opacity duration-300 peer-checked:opacity-100">自定义</span>
                                      <div class="absolute left-0.5 top-0.5 h-4 w-4 rounded-full bg-white shadow-md transition-transform duration-300 peer-checked:translate-x-[2.8rem]"></div>
                                  </label>
                              </div>
                          </div>
                          <div id="style-cover-section" class="mt-2 pl-1 ${this.currentEvent.coverType === "custom" ? "" : "hidden"}">
                              <!-- 预览区 -->
                              <div id="style-cover-preview-area" class="items-center gap-4 ${currentCoverUrl ? "flex" : "hidden"}">
                                <img id="style-cover-img" src="${currentCoverUrl || ""}" alt="封面预览" class="rounded border bg-white p-1 h-16 w-auto object-contain shadow-sm">
                                <button id="style-cover-remove-btn" class="text-sm text-red-600 hover:underline">删除封面图</button>
                              </div>
                              <!-- 上传区 -->
                              <div id="style-cover-upload-area" class="${currentCoverUrl ? "hidden" : "block"}">
                                <input type="file" id="style-cover-upload" accept="image/*" class="w-full mt-2 text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-gray-200 file:text-gray-700 hover:file:bg-gray-300" />
                                 <p class="text-xs text-gray-500 mt-2 ml-1"> 建议尺寸 595 x 842px (A4纵向), 大小不超过2M。</p>
                              </div>
                          </div>
                      </div>

                      <!-- 背景图部分 -->
                      <div>
                          <label class="block text-sm font-bold text-gray-700 mb-2">礼簿页背景图</label>

                          <!-- 预览区 -->
                          <div id="style-bg-preview-area" class="${bgUrl ? "flex" : "hidden"} items-center gap-4 transition-all">
                            <img id="style-bg-img" src="${bgUrl || ""}" class="rounded border bg-white p-1 h-16 w-auto object-contain shadow-sm">
                            <button id="style-bg-remove-btn" class="text-sm text-red-600 hover:underline">删除背景图</button>
                          </div>

                          <!-- 上传区 -->
                          <div id="style-bg-upload-area" class="${bgUrl ? "hidden" : "block"} transition-all">
                             <input type="file" id="style-bg-upload" accept="image/*" class="w-full mt-2 text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-gray-200 file:text-gray-700 hover:file:bg-gray-300" />
                             <p class="text-xs text-gray-500 mt-2 ml-1"> 建议浅色底纹。A4横版, 建议尺寸 842 x 595px。</p>
                          </div>
                      </div>
                  </div>
                </div>
                
                <!-- 第二部分：打印导出选项 -->
                <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                    <!-- 保持原有打印选项逻辑不变 -->
                    <div class="flex gap-2 text-sm items-center flex-wrap">
                      <label class="block text-sm font-bold text-gray-700 ">礼簿附页选项：</label>
                        <label class="flex items-center"><input type="checkbox" id="style-print-cover" class="w-4 h-4 themed-ring rounded mr-1" ${printOptions.printCover ? "checked" : ""}><span>封面</span></label>
                        <label class="flex items-center"><input type="checkbox" id="style-show-cover-title" class="w-4 h-4 themed-ring rounded mr-1" ${
                          printOptions.showCoverTitle ? "checked" : ""
                        }><span>封面标题</span></label>
                        <label class="flex items-center"><input type="checkbox" id="style-print-appendix" class="w-4 h-4 themed-ring rounded mr-1" ${
                          printOptions.printAppendix ? "checked" : ""
                        }><span>备注附录</span></label>
                        <label class="flex items-center"><input type="checkbox" id="style-print-summary" class="w-4 h-4 themed-ring rounded mr-1" ${printOptions.printSummary ? "checked" : ""}><span>总计页</span></label>
                        <label class="flex items-center"><input type="checkbox" id="style-print-end-page" class="w-4 h-4 themed-ring rounded mr-1" ${printOptions.printEndPage ? "checked" : ""}><span>封底</span></label>
                    </div>
                    <div class="flex gap-2 text-sm items-center">
                        <label class="block text-sm font-bold text-gray-700 mr-1">礼簿每页显示条数:</label>
                        <div class="flex items-center gap-2">
                            <input type="number" id="style-items-per-page" min="6" max="20" step="1" value="${this.getItemsPerPage()}"
                                class="w-12 p-2 border border-gray-300 rounded themed-ring text-center font-bold bg-white">
                            <span class="text-xs text-gray-500">建议 10-20</span>
                        </div>
                    </div>
                  </div>

                <!-- 第三部分：文字样式配置 -->
                <div>
                  <div class="flex justify-between items-center mb-3 pb-2 border-b">
                      <h3 class="font-bold text-gray-800 text-sm">礼簿字体与颜色</h3>
                      <div class="flex gap-2">
                          <button id="reset-style-btn" class="text-xs border border-gray-300 bg-white hover:bg-gray-100 text-gray-700 px-3 py-1.5 rounded shadow-sm transition-colors flex items-center">
                              <i class="ri-refresh-line mr-1"></i>恢复默认
                          </button>
                          ${
                            "queryLocalFonts" in window
                              ? `<button id="load-local-fonts-btn" class="text-xs themed-button-primary px-3 py-1.5 rounded shadow-sm transition-colors flex items-center"><i class="ri-font-size mr-1"></i>使用本地字体</button>`
                              : ""
                          }
                      </div>
                  </div>
                  <div class="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-5 gap-3">
                      ${textStyleHtml}
                  </div>
                </div>
              </div>`;

          this.ui.showModal("礼簿样式设置", content, [
            { text: "取消", class: "themed-button-secondary border px-4 py-2 rounded" },
            {
              text: "保存设置",
              class: "themed-button-primary px-6 py-2 rounded font-bold",
              handler: async () => {
                try {
                  // --- 背景图 ---
                  const bgFile = document.getElementById("style-bg-upload")?.files[0];
                  const isBgRemoved = document.getElementById("style-bg-preview-area").classList.contains("hidden");

                  if (bgFile) {
                    if (bgFile.size > 10 * 1024 * 1024) {
                      this.ui.showNotification("背景图片过大", "error");
                      return;
                    }
                    await ImageCache.saveBackground(this.currentEvent.id, bgFile);
                  } else if (isBgRemoved) {
                    // 仅在点了删除且没有新上传时才执行删除
                    await ImageCache.deleteBackground(this.currentEvent.id);
                  }

                  // --- 封面图 ---
                  const coverFile = document.getElementById("style-cover-upload")?.files[0];
                  const isCoverRemoved = document.getElementById("style-cover-preview-area").classList.contains("hidden");
                  const isCoverCustom = document.getElementById("style-cover-toggle").checked;
                  let newCoverType = isCoverCustom ? "custom" : "default";

                  // 特殊情况修正：选了自定义，但没图（旧的被删了且没新的），强制回退默认
                  if (newCoverType === "custom" && !coverFile && isCoverRemoved) {
                    newCoverType = "default";
                  }

                  if (coverFile) {
                    await ImageCache.saveEventCover(this.currentEvent.id, coverFile);
                    newCoverType = "custom"; // 只要上传了图就是自定义
                  } else if (newCoverType === "default") {
                    await ImageCache.deleteEventCover(this.currentEvent.id);
                  }

                  // === 保存打印选项 ===
                  const pdfEngine = this.currentEvent.printOptions?.pdfEngine || "browser";
                  const newPrintOptions = {
                    printCover: document.getElementById("style-print-cover").checked,
                    showCoverTitle: document.getElementById("style-show-cover-title").checked,
                    printAppendix: document.getElementById("style-print-appendix").checked,
                    printSummary: document.getElementById("style-print-summary").checked,
                    printEndPage: document.getElementById("style-print-end-page").checked,
                    pdfEngine: pdfEngine,
                  };

                  // === 保存文字样式 ===
                  const currentDefaults = getDefaults();
                  const newStyle = { localFonts: this.currentEvent.customStyle?.localFonts || [] };

                  ["coverText", "pageInfo", "name", "type", "amountChinese"].forEach((field) => {
                    // 收集输入值
                    const fontSel = document.querySelector(`select[data-field="${field}"][data-prop="font"]`);
                    const inputFont = fontSel ? fontSel.value : "";

                    const fieldConfig = {};
                    if (inputFont) fieldConfig.font = inputFont;
                    const def = currentDefaults[field];

                    if (field === "pageInfo") {
                      // 特殊处理 pageInfo 的两个颜色
                      const themeColorInp = document.querySelector(`input[data-field="${field}"][data-prop="themeColor"]`);
                      const baseColorInp = document.querySelector(`input[data-field="${field}"][data-prop="baseColor"]`);

                      const themeVal = themeColorInp ? themeColorInp.value.trim().toLowerCase() : null;
                      const baseVal = baseColorInp ? baseColorInp.value.trim().toLowerCase() : null;

                      if (themeVal && themeVal !== def.themeColor.toLowerCase()) fieldConfig.themeColor = themeVal;
                      if (baseVal && baseVal !== def.baseColor.toLowerCase()) fieldConfig.baseColor = baseVal;
                    } else {
                      // 标准处理 Size / Color
                      const sizeInp = document.querySelector(`input[data-field="${field}"][data-prop="size"]`);
                      const colorInp = document.querySelector(`input[data-field="${field}"][data-prop="color"]`);

                      let inputSize = sizeInp && sizeInp.value ? parseInt(sizeInp.value) : null;
                      if (inputSize && isNaN(inputSize)) inputSize = null;
                      const inputColor = colorInp ? colorInp.value.trim().toLowerCase() : null;

                      if (inputSize !== null && inputSize !== def.size) fieldConfig.size = inputSize;
                      if (inputColor && inputColor !== def.color.toLowerCase()) fieldConfig.color = inputColor;
                    }

                    // 如果有自定义配置则保存
                    if (Object.keys(fieldConfig).length > 0) newStyle[field] = fieldConfig;
                  });

                  const itemsPerPageInput = document.getElementById("style-items-per-page");
                  let newItemsPerPage = Math.min(Math.max(parseInt(itemsPerPageInput.value) || 12, 6), 24);

                  this.currentEvent.itemsPerPage = newItemsPerPage;
                  this.currentEvent.customStyle = newStyle;
                  this.currentEvent.coverType = newCoverType;
                  this.currentEvent.printOptions = newPrintOptions;

                  await this.giftRepository.updateEvent(this.currentEvent);

                  this.ui.closeModal();
                  this.applyCustomGiftBookStyle();

                  const totalPages = Math.ceil(this.gifts.length / newItemsPerPage) || 1;
                  if (this.currentPage > totalPages) {
                    this.currentPage = totalPages;
                  }
                  this.giftManager.ensureCurrentPageDecrypted();
                  this.giftManager.render();
                  this.session.save(this.currentEvent, this.currentPassword);
                  this.ui.showNotification("样式及打印设置已保存", "success");
                } catch (error) {
                  console.error("保存样式失败:", error);
                  this.ui.showNotification("保存失败，请重试", "error");
                }
              },
            },
          ]);

          // === 事件绑定 ===
          setTimeout(() => {
            // 辅助函数：绑定图片预览/移除逻辑
            const bindImageLogic = (prefix) => {
              const uploadInput = document.getElementById(`${prefix}-upload`);
              const previewArea = document.getElementById(`${prefix}-preview-area`);
              const uploadArea = document.getElementById(`${prefix}-upload-area`);
              const previewImg = document.getElementById(`${prefix}-img`);
              const removeBtn = document.getElementById(`${prefix}-remove-btn`);

              if (uploadInput) {
                uploadInput.addEventListener("change", (e) => {
                  const file = e.target.files[0];
                  if (file) {
                    const reader = new FileReader();
                    reader.onload = (evt) => {
                      previewImg.src = evt.target.result;
                      previewArea.classList.remove("hidden");
                      previewArea.classList.add("flex");
                      uploadArea.classList.add("hidden");
                    };
                    reader.readAsDataURL(file);
                  }
                });
              }
              if (removeBtn) {
                removeBtn.onclick = () => {
                  previewImg.src = "";
                  uploadInput.value = ""; // 清空 input value
                  previewArea.classList.add("hidden");
                  previewArea.classList.remove("flex");
                  uploadArea.classList.remove("hidden");
                };
              }
            };

            // 绑定封面和背景
            bindImageLogic("style-cover");
            bindImageLogic("style-bg");

            // 封面切换开关
            const coverToggle = document.getElementById("style-cover-toggle");
            const coverSection = document.getElementById("style-cover-section");
            if (coverToggle) {
              coverToggle.addEventListener("change", (e) => {
                coverSection.classList.toggle("hidden", !e.target.checked);
              });
            }

            // 颜色选择器实时预览
            document.querySelectorAll('input[type="color"]').forEach((input) => {
              input.addEventListener("input", (e) => {
                const val = e.target.value;
                const parent = e.target.parentNode;
                if (parent) {
                  const preview = parent.querySelector(".color-preview");
                  const text = parent.querySelector(".color-text");
                  if (preview) preview.style.backgroundColor = val;
                  if (text) text.innerText = val;
                }
              });
            });

            // 重置按钮逻辑
            document.getElementById("reset-style-btn")?.addEventListener("click", () => {
              const defs = getDefaults();
              // 重置标准字段
              ["name", "type", "amountChinese", "coverText"].forEach((key) => {
                const sInput = document.querySelector(`input[data-field="${key}"][data-prop="size"]`);
                const cInput = document.querySelector(`input[data-field="${key}"][data-prop="color"]`);
                if (sInput) sInput.value = defs[key].size;
                if (cInput) {
                  cInput.value = defs[key].color;
                  cInput.dispatchEvent(new Event("input")); // 触发预览更新
                }
              });
              // 重置 pageInfo 特殊字段
              const themeInput = document.querySelector(`input[data-field="pageInfo"][data-prop="themeColor"]`);
              const baseInput = document.querySelector(`input[data-field="pageInfo"][data-prop="baseColor"]`);
              if (themeInput) {
                themeInput.value = defs.pageInfo.themeColor;
                themeInput.dispatchEvent(new Event("input"));
              }
              if (baseInput) {
                baseInput.value = defs.pageInfo.baseColor;
                baseInput.dispatchEvent(new Event("input"));
              }

              // 重置所有字体选择
              document.querySelectorAll('select[data-prop="font"]').forEach((sel) => (sel.value = ""));

              this.ui.showNotification("已重置默认值 (需点击保存生效)", "info");
            });

            // 加载本地字体
            document.getElementById("load-local-fonts-btn")?.addEventListener("click", async () => {
              try {
                const fonts = await window.queryLocalFonts();
                const safeFonts = fonts.map((f) => ({
                  postscriptName: f.postscriptName,
                  family: f.family,
                  fullName: f.fullName || f.family,
                }));
                this.currentEvent.customStyle = this.currentEvent.customStyle || {};
                this.currentEvent.customStyle.localFonts = safeFonts;
                await this.giftRepository.updateEvent(this.currentEvent);
                this.showGiftBookStyleModal(); // 重新打开以刷新列表
                this.ui.showNotification(`已加载 ${safeFonts.length} 种字体`, "success");
              } catch (e) {
                this.ui.showNotification("字体加载取消或不支持", "info");
              }
            });
          }, 50);
        }

        /**
         * 应用自定义礼簿样式到屏幕 + 打印变量
         */
        async applyCustomGiftBookStyle() {
          const s = this.currentEvent?.customStyle || {};
          const root = document.documentElement;

          const customBgUrl = await ImageCache.getBackgroundUrl(this.currentEvent.id);
          if (customBgUrl) {
            const img = new Image();
            img.src = customBgUrl;
            root.style.setProperty("--custom-bg-image", `url("${customBgUrl}")`);
          } else {
            root.style.removeProperty("--custom-bg-image");
          }

          let customCoverUrl = null;
          if (this.currentEvent.coverType === "custom") {
            const cachedUrl = await ImageCache.getEventCoverUrl(this.currentEvent.id);
            if (cachedUrl) customCoverUrl = cachedUrl;
          }

          if (customCoverUrl) {
            const img = new Image();
            img.src = customCoverUrl;
            root.style.setProperty("--custom-cover-image", `url("${customCoverUrl}")`);
          } else {
            root.style.removeProperty("--custom-cover-image");
          }

          const itemsCount = this.getItemsPerPage();
          root.style.setProperty("--gift-grid-columns", itemsCount.toString());

          // === 更新：字段映射与变量应用 ===
          const stdFields = { name: "name", type: "type", amountChinese: "amount-chinese", coverText: "cover-text" };
          Object.entries(stdFields).forEach(([field, cssPrefix]) => {
            const cfg = s[field];
            const sizeVar = `--custom-${cssPrefix}-size`;
            const colorVar = `--custom-${cssPrefix}-color`;
            const fontVar = `--custom-${cssPrefix}-font`;

            if (cfg?.size) root.style.setProperty(sizeVar, cfg.size + "px");
            else root.style.removeProperty(sizeVar);

            if (cfg?.color) root.style.setProperty(colorVar, cfg.color);
            else root.style.removeProperty(colorVar);

            applyFontVar(cfg?.font, fontVar);
          });

          const pInfo = s.pageInfo || {};
          const themeColorVar = "--custom-print-theme-color";
          const baseColorVar = "--custom-print-base-color";
          const baseFontVar = "--custom-print-base-font";

          if (pInfo.themeColor) root.style.setProperty(themeColorVar, pInfo.themeColor);
          else root.style.removeProperty(themeColorVar);

          if (pInfo.baseColor) root.style.setProperty(baseColorVar, pInfo.baseColor);
          else root.style.removeProperty(baseColorVar);
          applyFontVar(pInfo.font, "--custom-page-info-font");
          applyFontVar(pInfo.font, "--custom-print-base-font");

          function applyFontVar(fontName, cssVarName) {
            if (fontName && s.localFonts) {
              const font = s.localFonts.find((f) => f.postscriptName === fontName);
              if (font) root.style.setProperty(cssVarName, `"${font.family}"`);
              else root.style.removeProperty(cssVarName);
            } else {
              root.style.removeProperty(cssVarName);
            }
          }
        }

        /**
         * 绑定历史记录查看按钮事件
         * @param {Array} history - 变更历史
         * @param {number} giftIndex - 礼金索引
         */
        bindViewOriginalEvents(history, giftIndex) {
          const showSnapshot = (historyIndex) => {
            const snapshot = history[historyIndex].snapshot;
            const snapshotLevel = snapshot.guestLevel !== undefined ? snapshot.guestLevel : 0;
            const snapshotLevelName = CONFIG.GUEST_LEVELS[snapshotLevel] || CONFIG.GUEST_LEVELS[0];

            const remarkDisplay = this.formatRemarkDisplay(snapshot.remarkData || "");

            const content = `
                        <div class="space-y-2 p-4 bg-gray-100 rounded text-left">
                          <p><strong>姓名:</strong> ${snapshot.name}</p>
                          <p><strong>金额:</strong> ${Utils.formatCurrency(snapshot.amount)} (${snapshot.type})</p>
                          <p><strong>宾客等级:</strong> ${snapshotLevelName}</p>
                          <p><strong>备注:</strong> ${remarkDisplay || "无"}</p>
                          <p class="text-xs text-gray-500 border-t pt-2 mt-2">此记录于 ${new Date(history[historyIndex].timestamp).toLocaleString()} 被修改存档。</p>
                        </div>
                      `;

            this.ui.elements.modal.classList.remove("modal-large");
            // 确保模态按钮可见
            this.ui.elements.modalActions.classList.remove("hidden");
            this.ui.showModal("历史记录快照", content, [
              {
                text: "返回详情",
                class: "themed-button-secondary border px-4 py-2 rounded",
                handler: () => this.showGiftDetails(giftIndex),
                keepOpen: true,
              },
            ]);
          };

          document.querySelectorAll(".btn-view-original, .btn-view-snapshot").forEach((btn) => {
            btn.onclick = (e) => showSnapshot(parseInt(e.target.dataset.historyIndex));
          });
        }

        /**
         * 启动礼金详情区域的行内编辑能力
         * 根据 fieldType 不同生成姓名、金额、备注的编辑界面
         * - 姓名：按字符拆分并限制每次纠错的修改数量
         * - 金额：提供金额输入与收款方式切换
         * - 备注：复用模态窗表单收集结构化备注
         */
        enableInlineEdit(giftIndex, fieldType) {
          const g = this.gifts[giftIndex].data;
          let targetAreaId, editHtml, saveHandler;
          let nameEditConfig = null;

          // 统一管理详情区域的操作按钮，方便在编辑时禁用/恢复状态
          const allButtons = ["btn-correct-name", "btn-modify-amount", "btn-edit-remarks"];
          // 根据编辑状态临时禁用/恢复纠错、金额与备注按钮
          const setInlineButtonsDisabled = (disabled) => {
            allButtons.forEach((btnId) => {
              const btn = document.getElementById(btnId);
              if (!btn) return;
              if (disabled) {
                btn.dataset.inlineDisabled = "true";
                btn.disabled = true;
                btn.classList.add("opacity-50", "cursor-not-allowed");
              } else if (btn.dataset.inlineDisabled === "true") {
                delete btn.dataset.inlineDisabled;
                if (btn.dataset.fixedDisabled === "true") {
                  btn.disabled = true;
                  btn.classList.add("opacity-50", "cursor-not-allowed");
                } else {
                  btn.disabled = false;
                  btn.classList.remove("opacity-50", "cursor-not-allowed");
                }
              }
            });
          };

          const cancelHandler = () => this.showGiftDetails(giftIndex);
          const cancelBtnHtml = `<button id="inline-cancel" class="text-sm px-3 py-1 rounded themed-button-secondary border">取消</button>`;
          const saveBtnHtml = `<button id="inline-save" class="text-sm px-3 py-1 rounded themed-button-primary">保存</button>`;

          // 姓名纠错：按字符拆分并基于历史次数限制可编辑数量
          if (fieldType === "name") {
            let originalChars = Array.from(g.name || "");
            if (originalChars.length === 0) originalChars = [""];
            const nameLength = originalChars.length;
            const computedLimit = nameLength <= 2 ? 1 : nameLength === 3 ? 2 : 3;
            const correctionCount = countNameCorrections(g.history);
            if (correctionCount >= 2) {
              this.ui.showNotification("该礼金姓名纠错次数已达上限。", "info");
              return;
            }
            let maxEditable = Math.max(1, Math.min(computedLimit, nameLength));
            if (correctionCount === 1) {
              // 第二次纠错：无论姓名长度，最多只能修改一个字符
              maxEditable = 1;
            }
            setInlineButtonsDisabled(true);
            // 展示剩余纠错次数，便于提示用户当前额度
            const remainingCorrections = Math.max(0, 2 - correctionCount);
            // 转义单字输入内容，避免特殊字符破坏 HTML
            const escapeChar = (char) => String(char).replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
            nameEditConfig = { originalChars, maxEditable };
            targetAreaId = "name-display-area";
            editHtml = `
                      <div class="themed-edit-area text-center space-y-3">
                        <label class="block font-medium">纠错姓名</label>
                        <div id="inline-name-inputs" class="flex justify-center gap-2 flex-wrap mb-1">
                          ${originalChars
                            .map(
                              (char, index) =>
                                `<input type="text" data-index="${index}" value="${escapeChar(
                                  char
                                )}" maxlength="1" class="w-10 h-10 text-center border rounded themed-ring focus:outline-none focus:ring-2 focus:ring-blue-400 selection:bg-blue-200" autocomplete="off" inputmode="text">`
                            )
                            .join("")}
                        </div>
                        <p class="text-xs text-gray-500">本次最多可修改${maxEditable}个字，剩余纠错次数${remainingCorrections}次。</p>
                        <div class="flex justify-center space-x-2">${cancelBtnHtml}${saveBtnHtml}</div>
                      </div>`;
            saveHandler = async () => {
              if (!nameEditConfig) return cancelHandler();
              const { originalChars, maxEditable } = nameEditConfig;
              const inputs = Array.from(document.querySelectorAll("#inline-name-inputs input"));
              if (inputs.length !== originalChars.length) return cancelHandler();
              const updatedChars = inputs.map((input) => input.value.trim());
              if (updatedChars.some((char) => char.length === 0)) {
                this.ui.showNotification("姓名的每个字都不能为空。", "error");
                return;
              }
              // 统计与原始姓名不同的字符数量，用于额度校验
              const changedCount = updatedChars.reduce((count, value, index) => (value !== originalChars[index] ? count + 1 : count), 0);
              if (changedCount === 0) {
                this.ui.showNotification("姓名未发生变化。", "info");
                return;
              }
              if (changedCount > maxEditable) {
                this.ui.showNotification(`本次最多可修改${maxEditable}个字。`, "error");
                return;
              }
              // 验证通过后合成新的完整姓名并提交保存
              const newName = updatedChars.join("");
              if (!newName || newName === g.name) return cancelHandler();
              const changeLog = `将姓名由 "${g.name}" 更正为 "${newName}"`;
              await this.giftManager.performUpdate(giftIndex, { name: newName }, changeLog, "correction");
            };
            // 金额调整：同时允许修改金额与收款方式
          } else if (fieldType === "amount") {
            const amountCorrectionCount = countAmountCorrections(g.history);
            if (amountCorrectionCount >= 1) {
              this.ui.showNotification("该礼金金额已修改过，无法再次调整。", "info");
              return;
            }
            setInlineButtonsDisabled(true);
            targetAreaId = "amount-display-area";
            editHtml = `
                      <div class="themed-edit-area">
                        <label>修改金额与类型</label>
                        <input type="number" id="inline-edit-amount" value="${g.amount}" min="0" step="0.01" class="w-full p-2 border rounded themed-ring mb-2">
                        <div class="flex flex-wrap gap-x-3 gap-y-1 mb-2">
                          ${["现金", "支付宝", "微信", "其他"]
                            .map(
                              (type) => `
                            <label class="flex items-center text-sm font-normal">
                              <input type="radio" name="inline-edit-type" value="${type}" ${g.type === type ? "checked" : ""} class="mr-1 themed-ring">${type}
                            </label>
                          `
                            )
                            .join("")}
                        </div>
                        <p class="text-xs text-gray-500 mb-2">提示：金额仅支持修改一次，请谨慎操作。</p>
                        <div class="flex justify-end space-x-2">${cancelBtnHtml}${saveBtnHtml}</div>
                      </div>`;
            saveHandler = async () => {
              // 解析用户输入的金额，并同步记录新的收款方式
              const newAmount = parseFloat(document.getElementById("inline-edit-amount").value);
              const newType = document.querySelector('input[name="inline-edit-type"]:checked').value;
              if (isNaN(newAmount) || newAmount < 0) return this.ui.showNotification("请输入有效金额。", "error");

              if (newAmount === g.amount && newType === g.type) return cancelHandler();

              let logs = [];
              if (newAmount !== g.amount) logs.push(`将金额由 ${g.amount} 修改为 ${newAmount}`);
              if (newType !== g.type) logs.push(`将类型由 ${g.type} 修改为 ${newType}`);
              await this.giftManager.performUpdate(giftIndex, { amount: newAmount, type: newType }, logs.join("，"), "correction");
            };
            // 备注编辑：复用统一模态窗口以保持体验一致
          } else if (fieldType === "remarks") {
            setInlineButtonsDisabled(true);
            // 备注编辑：直接在一个新的、干净的模态窗口中处理
            // 备注编辑直接唤起模态窗，复用统一的字段渲染逻辑
            const currentRemarkData = this.normalizeRemarkData(g.remarkData);

            // 使用统一的方法动态生成所有备注字段的输入表单HTML
            const modalContent = `
                        <div class="space-y-3 text-left">
                          ${this.generateRemarkInputsHTML(currentRemarkData)}
                        </div>
                      `;

            // 定义保存按钮的点击事件处理器
            const saveRemarkHandler = async () => {
              // 从模态框的输入框中收集最新的备注数据
              const newRemarkData = this.collectRemarkData(true);

              // 比较新旧数据，如果没有实际变化，则直接返回详情页，避免不必要的操作
              if (JSON.stringify(currentRemarkData) === JSON.stringify(newRemarkData)) {
                this.showGiftDetails(giftIndex); // 直接返回，不关闭，让用户看到原样
                return;
              }

              // 如果有变化，则动态生成详细的修改日志
              const changes = [];
              this.REMARK_LABELS.forEach(({ key, label }) => {
                const oldValue = currentRemarkData[key] || "";
                const newValue = newRemarkData[key] || "";
                if (oldValue !== newValue) {
                  const fieldName = label;
                  const from = oldValue ? `"${oldValue}"` : "（空）";
                  const to = newValue ? `"${newValue}"` : "（空）";
                  changes.push(`${fieldName}从 ${from} 修改为 ${to}`);
                }
              });

              const changeLog = changes.join("；");

              // 理论上，如果 changeLog 为空，上面的 JSON 比较就会返回，但作为双重保障
              if (!changeLog) {
                this.showGiftDetails(giftIndex);
                return;
              }

              // 执行更新操作
              await this.giftManager.performUpdate(giftIndex, { remarkData: newRemarkData }, changeLog, "remark");
            };

            // 显示模态框
            this.ui.showModal("修改备注", modalContent, [
              {
                text: "返回详情",
                class: "themed-button-secondary border px-4 py-2 rounded",
                role: "secondary",
                handler: () => this.showGiftDetails(giftIndex), // 点击返回时，重新渲染详情弹窗
                keepOpen: true,
              },
              {
                text: "保存",
                class: "themed-button-primary px-4 py-2 rounded",
                role: "primary",
                handler: saveRemarkHandler,
                keepOpen: true, // 保持打开，直到保存成功或失败后由程序决定下一步
              },
            ]);

            // 确保模态框不是大尺寸模式
            this.ui.elements.modal.classList.remove("modal-large");

            // 延迟后，自动聚焦到第一个备注输入框，提升用户体验
            // 使用 querySelector 保证能找到由 REMARK_LABELS 定义的第一个字段
            setTimeout(() => {
              const firstRemarkKey = this.REMARK_LABELS.find((f) => f.key !== "custom")?.key;
              if (firstRemarkKey) {
                document.querySelector(`[data-remark-type="${firstRemarkKey}"]`)?.focus();
              }
            }, 50);

            return;
          }
          const targetArea = document.getElementById(targetAreaId);
          if (targetArea) {
            targetArea.innerHTML = editHtml;
            document.getElementById("inline-cancel").onclick = cancelHandler;
            document.getElementById("inline-save").onclick = saveHandler;

            // 绑定回车键保存逻辑
            const handleEnterKey = (e) => {
              const isTextarea = e.target?.tagName === "TEXTAREA";
              const shouldSave = e.key === "Enter" && !isTextarea;
              if (shouldSave) {
                e.preventDefault();
                e.stopPropagation();
                saveHandler();
              }
            };
            targetArea.addEventListener("keydown", handleEnterKey);

            this.ui.elements.modalActions.classList.add("hidden");

            // 姓名纠错专用交互：监听输入并在达上限时禁用其他字符
            if (fieldType === "name" && nameEditConfig) {
              const nameInputsContainer = document.getElementById("inline-name-inputs");
              if (nameInputsContainer) {
                const inputs = Array.from(nameInputsContainer.querySelectorAll("input"));
                const changedIndices = new Set();

                // 根据已修改的字符数量启用/禁用输入框
                const enforceLimit = () => {
                  const reachedLimit = changedIndices.size >= nameEditConfig.maxEditable;
                  // 逐个输入框绑定 IME、输入、聚焦等事件，保持校验准确
                  inputs.forEach((input) => {
                    const index = parseInt(input.dataset.index, 10);
                    if (Number.isNaN(index)) return;
                    if (!reachedLimit || changedIndices.has(index)) {
                      input.disabled = false;
                      input.classList.remove("bg-gray-100", "cursor-not-allowed");
                    } else {
                      input.disabled = true;
                      input.classList.add("bg-gray-100", "cursor-not-allowed");
                    }
                  });
                };

                inputs.forEach((input) => {
                  let isComposing = false;
                  const handleChange = () => {
                    const index = parseInt(input.dataset.index, 10);
                    if (Number.isNaN(index)) return;
                    const trimmedValue = input.value.trim();
                    if (trimmedValue !== input.value) input.value = trimmedValue;
                    if (trimmedValue.length > 1) {
                      const normalized = Array.from(trimmedValue).slice(-1).join("");
                      input.value = normalized;
                    }
                    if (input.value !== nameEditConfig.originalChars[index]) {
                      if (input.value.length > 0) {
                        changedIndices.add(index);
                      } else {
                        changedIndices.delete(index);
                      }
                    } else {
                      changedIndices.delete(index);
                    }
                    enforceLimit();
                  };
                  input.addEventListener("compositionstart", () => {
                    isComposing = true;
                  });
                  input.addEventListener("compositionend", () => {
                    isComposing = false;
                    handleChange();
                  });
                  input.addEventListener("input", () => {
                    if (isComposing) return;
                    handleChange();
                  });
                  input.addEventListener("focus", () => input.select());
                });

                enforceLimit();
              }
            }
          }
        }

        /**
         * 更新宾客等级
         * @param {number} giftIndex - 礼金索引
         * @param {number} newLevel - 新等级索引 (0-4)
         * @param {number} oldLevel - 旧等级索引 (0-4)
         */
        async updateGuestLevel(giftIndex, newLevel, oldLevel) {
          try {
            const giftObject = this.gifts[giftIndex];
            const currentData = { ...giftObject.data };
            const now = new Date().toISOString();
            const newlevelUpdateTime = Date.now();

            const oldLevelName = CONFIG.GUEST_LEVELS[oldLevel];
            const newLevelName = CONFIG.GUEST_LEVELS[newLevel];

            // 等级变化，记录历史，更新 levelUpdateTime
            const historyEntry = {
              timestamp: now,
              changeLog: `将宾客等级从 "${oldLevelName}" 修改为 "${newLevelName}"`,
              snapshot: this.giftManager.createSnapshot(currentData),
              type: "levelChange",
            };

            const updatedData = {
              ...currentData,
              guestLevel: newLevel,
              timestamp: now,
              history: currentData.history ? [...currentData.history, historyEntry] : [historyEntry],
            };

            // timestamp 在 encryptedData 中，levelUpdateTime 单独存储
            const encryptedData = CryptoService.encrypt(updatedData, this.currentPassword);
            await this.giftRepository.updateGift(
              this.giftManager.buildGiftRecordForUpdate(giftObject, {
                encryptedData,
                guestLevelWeight: newLevel,
                levelUpdateTime: newlevelUpdateTime,
              })
            );

            // 优化：只重新排序内存数据，避免重复查询和解密
            const updatedGiftId = giftObject.id;
            this.gifts[giftIndex].data = updatedData;
            this.gifts[giftIndex].encryptedData = encryptedData;
            this.gifts[giftIndex].guestLevelWeight = newLevel;
            this.gifts[giftIndex].levelUpdateTime = newlevelUpdateTime;
            this.giftManager.sortGiftsByLevel();

            const newIndex = this.gifts.findIndex((g) => g.id === updatedGiftId);
            this.currentPage = newIndex !== -1 ? Math.floor(newIndex / app.getItemsPerPage()) + 1 : this.currentPage;
            this.giftManager.render();

            this.ui.closeModal();
            setTimeout(() => this.showGiftDetails(newIndex, { fromStats: false }), 150);
            this.ui.showNotification(`宾客等级已更新为 "${newLevelName}"。`, "success");
          } catch (error) {
            console.error("等级更新失败，请重试。:", error);
            this.ui.showNotification("等级更新失败，请重试。", "error");
          }
        }

        /**
         * 统一的管理员密码校验方法
         * @param {string} title - 弹窗标题
         * @param {string} message - 提示信息
         * @param {string} expectedHash - 期望的密码哈希值（可选，默认使用当前事项）
         * @param {boolean} forceVerify - 是否强制验证（true 时必须输入密码，不使用免密缓存）
         * @returns {Promise<string|null>} 返回原始密码（成功）或 null（取消/错误）
         */
        async requestAdminPassword(title, message = "", expectedHash = null, forceVerify = false) {
          const hashToCompare = expectedHash || this.currentEvent.passwordHash;

          // 如果不强制验证，尝试从缓存中获取密码
          if (!forceVerify) {
            const cachedPassword = this.getCachedAdminPassword();
            if (cachedPassword && CryptoService.hash(cachedPassword) === hashToCompare) {
              return cachedPassword; // 自动验证通过
            }
          }

          return new Promise((resolve) => {
            this.ui.elements.modal.classList.remove("modal-large");
            const content = `
                        ${(message && `<p class="text-sm text-gray-600 mb-3">${message}</p>`) || ""}
                        <input type="password" id="admin-pwd-input" class="w-full p-2 border rounded themed-ring" placeholder="请输入管理密码">
                      `;

            this.ui.showModal(title, content, [
              { text: "取消", class: "themed-button-secondary border px-4 py-2 rounded", handler: () => resolve(null) },
              {
                text: "确认",
                class: "themed-button-primary px-4 py-2 rounded",
                handler: () => {
                  const inputPassword = document.getElementById("admin-pwd-input").value;
                  const isCorrect = CryptoService.hash(inputPassword) === hashToCompare;

                  if (isCorrect) {
                    // 如果勾选了N分钟免密，则缓存密码
                    if (!forceVerify) {
                      const skipVerify = document.getElementById("skip-verify-5min")?.checked;
                      if (skipVerify) {
                        this.cacheAdminPassword(inputPassword, hashToCompare);
                      }
                    }
                    resolve(inputPassword); // 返回原始密码
                  } else {
                    this.ui.showNotification("密码错误，请重新输入。", "error");
                    resolve(null); // 密码错误
                  }
                },
              },
            ]);

            setTimeout(() => {
              // 将复选框添加到 modal-actions 左侧
              if (!forceVerify) {
                const actionsContainer = this.ui.elements.modalActions;
                const checkboxDiv = document.createElement("div");
                checkboxDiv.className = "flex items-center mr-auto";
                const minutes = CONFIG.PASSWORD_CACHE_DURATION;
                checkboxDiv.innerHTML = `
                            <input type="checkbox" id="skip-verify-5min" class="w-4 h-4  rounded themed-ring cursor-pointer">
                            <label for="skip-verify-5min" class="ml-2 text-sm text-gray-600 cursor-pointer select-none whitespace-nowrap">${minutes}分钟内不再校验管理密码</label>
                          `;
                actionsContainer.insertBefore(checkboxDiv, actionsContainer.firstChild);
              }
              document.getElementById("admin-pwd-input")?.focus();
            }, 50);
          });
        }

        /**
         * 缓存管理员密码 - N 分钟有效
         * @param {string} password - 原始密码
         * @param {string} passwordHash - 密码哈希值（作为加密密钥）
         */
        cacheAdminPassword(password, passwordHash) {
          if (!this.currentEvent) return;
          this.passwordCache.store(this.currentEvent.id, password, passwordHash);
        }

        /**
         * 从缓存中获取管理员密码
         * @returns {string|null} 返回密码或 null（如果过期或不存在）
         */
        getCachedAdminPassword() {
          if (!this.currentEvent) return null;
          return this.passwordCache.retrieve(this.currentEvent.id, this.currentEvent.passwordHash);
        }

        /**
         * 填充语音播报音色列表
         * 从浏览器获取可用中文语音并填充下拉框
         * 使用 DocumentFragment 减少重绘
         */
        populateVoiceList(targetSelect = this.ui.elements.eventVoiceSelect, selectedValue = targetSelect?.value || "") {
          if (!targetSelect) return;
          if (!("speechSynthesis" in window)) {
            // 如果不支持语音，直接清空或显示默认，并退出函数防止报错
            targetSelect.innerHTML = '<option value="">设备不支持语音</option>';
            return;
          }
          const voices = speechSynthesis.getVoices().filter((v) => v.lang.startsWith("zh"));
          const fragment = document.createDocumentFragment();
          const defaultOption = document.createElement("option");
          defaultOption.value = "";
          defaultOption.textContent = "默认音色";
          fragment.appendChild(defaultOption);

          let hasSelectedVoice = false;
          voices.forEach((voice) => {
            const option = document.createElement("option");
            option.value = voice.name;
            option.textContent = `${voice.name} (${voice.lang})`;
            if (voice.name === selectedValue) {
              option.selected = true;
              hasSelectedVoice = true;
            }
            fragment.appendChild(option);
          });

          if (selectedValue && !hasSelectedVoice) {
            defaultOption.selected = true;
          } else if (!selectedValue) {
            defaultOption.selected = true;
          }

          targetSelect.innerHTML = "";
          targetSelect.appendChild(fragment);
        }

        /**
         * 切换备注预设选项
         * @param {string} preset - 预设键
         * @param {HTMLElement} btn - 触发按钮
         */
        toggleRemarkPreset(preset, btn) {
          const activeClass = "themed-button-primary";
          const inactiveClass = "themed-button-secondary";
          if (this.selectedRemarkPresets.has(preset)) {
            this.selectedRemarkPresets.delete(preset);
            btn.classList.remove(activeClass, inactiveClass);
          } else {
            this.selectedRemarkPresets.add(preset);
            btn.classList.add(activeClass, inactiveClass);
          }
          this.updateRemarkInputs();
        }

        /**
         * 更新备注输入框
         * 根据已选预设动态生成输入字段
         */
        updateRemarkInputs() {
          const container = document.getElementById("remark-inputs-container");

          // 保存当前值
          const currentValues = {};
          container.querySelectorAll("[data-remark-type]").forEach((input) => {
            currentValues[input.dataset.remarkType] = input.value;
          });

          container.innerHTML = "";

          const orderedPresets = this.REMARK_LABELS.map((item) => item.key).filter((key) => key !== "custom");

          orderedPresets.forEach((preset) => {
            if (this.selectedRemarkPresets.has(preset)) {
              const remarkConfig = this.REMARK_LABELS.find((item) => item.key === preset);
              if (remarkConfig) {
                const inputDiv = document.createElement("div");
                inputDiv.className = "flex items-center";
                inputDiv.innerHTML = `
                        <label class="text-sm font-medium text-gray-700 w-12">${remarkConfig.label}:</label>
                        <input type="text" class="flex-1 p-2 border rounded themed-ring"
                              data-remark-type="${preset}"
                              placeholder="请输入${remarkConfig.label}"
                              value="${currentValues[preset] || ""}">
                      `;
                container.appendChild(inputDiv);
              }
            }
          });
        }

        /**
         * 收集备注数据
         * @param {boolean} isEdit - 是否在编辑模式
         * @returns {Object} 备注对象
         */
        collectRemarkData(isEdit) {
          // 确定查找的范围 (上下文)
          // scope为真，说明是弹窗，范围是 #modal-content
          // 否则说明是主界面，范围是 #add-gift-form (这是您的思路)

          const scope = isEdit ? document.getElementById("modal-content") : this.ui.elements.addGiftForm;
          // 如果找不到范围，直接返回空，增加代码健壮性
          if (!scope) return {};

          const remarkData = {};
          // 2. 在确定的范围内，查找所有带 data-remark-type 属性的输入元素
          scope.querySelectorAll("[data-remark-type]").forEach((input) => {
            const type = input.dataset.remarkType;
            const value = input.value.trim();
            if (value) {
              remarkData[type] = value;
            }
          });

          return remarkData;
        }

        /**
         * 生成备注输入表单 HTML
         * @param {Object|string} remarkData - 备注数据
         * @returns {string} HTML 字符串
         */
        generateRemarkInputsHTML(remarkData = {}) {
          const normalized = this.normalizeRemarkData(remarkData);
          return this.REMARK_LABELS.map(({ key, label }) => {
            const value = normalized[key] || "";
            const placeholder = `请输入${label}(选填)`;

            if (key === "custom") {
              return `
                        <div class="mt-2">
                          <label class="font-medium text-gray-700 block mb-1">${label}：</label>
                          <textarea data-remark-type="${key}" class="w-full p-2 border rounded themed-ring" rows="2" placeholder="${placeholder}">${value}</textarea>
                        </div>
                      `;
            } else {
              return `
                        <div class="flex items-center">
                          <label class="font-medium text-gray-700 w-12">${label}：</label>
                          <input type="text" data-remark-type="${key}" class="flex-1 p-2 border rounded themed-ring" placeholder="${placeholder}" value="${value}">
                        </div>
                      `;
            }
          }).join("\n");
        }

        /**
         * 规范化备注数据
         * 兼容旧版字符串备注
         * @param {Object|string|null} remarkData
         * @returns {Object}
         */
        normalizeRemarkData(remarkData) {
          if (!remarkData) return {};
          if (typeof remarkData === "string") {
            const trimmed = remarkData.trim();
            return trimmed ? { custom: trimmed } : {};
          }
          if (typeof remarkData === "object") {
            return { ...remarkData };
          }
          return {};
        }

        /**
         * 将备注对象转换为显示文本
         * @param {Object|string} remarkData - 备注数据
         * @param {string} separator - 分隔符
         * @returns {string}
         */
        formatRemarkDisplay(remarkData, separator = "; ") {
          const normalized = this.normalizeRemarkData(remarkData);
          if (Object.keys(normalized).length === 0) {
            return typeof remarkData === "string" ? remarkData.trim() : "";
          }
          const parts = [];
          this.REMARK_LABELS.forEach(({ key, label }) => {
            if (normalized[key]) {
              parts.push(`${key !== "custom" ? label + "：" : ""}${normalized[key]}`);
            }
          });

          return parts.join(separator);
        }

        /**
         * 格式化备注信息以显示在详情页面
         * @param {Object|string} remarkData - 备注数据
         * @returns {string} HTML 字符串
         */
        formatRemarkDetailsDisplay(remarkData) {
          const normalized = this.normalizeRemarkData(remarkData);
          if (Object.keys(normalized).length === 0) {
            return '<p class="text-gray-500">（无备注）</p>';
          }

          let html = "";
          const gridItems = [];

          this.REMARK_LABELS.forEach(({ key, label }) => {
            if (normalized[key]) {
              if (key === "custom") {
                html += `<div class="mb-2">${normalized[key]}</div>`;
              } else {
                gridItems.push(`<div><span class="text-sm font-bold">${label}：</span>${normalized[key]}</div>`);
              }
            }
          });

          if (gridItems.length > 0) {
            html += `<div class="grid grid-cols-2 gap-2">${gridItems.join("")}</div>`;
          }

          return html || '<p class="text-gray-500">（无备注）</p>';
        }

        /**
         * 检查是否存在备注
         * @param {Object} giftData - 礼金数据对象
         * @returns {boolean}
         */
        hasRemarkData(giftData) {
          const normalized = this.normalizeRemarkData(giftData?.remarkData);
          return Object.keys(normalized).length > 0;
        }

        /**
         * 重置备注预设选项到默认状态
         */
        resetRemarkPresets() {
          this.selectedRemarkPresets.clear();

          // 2. 移除所有按钮的高亮状态
          document.querySelectorAll(".remark-preset-btn").forEach((btn) => {
            btn.classList.remove("themed-button-primary");
            btn.classList.add("themed-button-secondary");
          });

          // 3. 清空固定的自定义备注输入框
          const customInput = document.getElementById("guest-remark-custom");
          if (customInput) {
            customInput.value = "";
          }

          // 4. 更新（清空）动态输入框区域
          this.updateRemarkInputs();
        }

        /**
         * 预览语音音色
         * @param {HTMLSelectElement} selectElement - 语音选择器
         */
        previewSelectedVoice(selectElement) {
          if (!("speechSynthesis" in window)) {
            this.ui.showNotification("当前浏览器不支持语音播报功能。", "error");
            return;
          }

          speechSynthesis.cancel();
          const selectedVoiceName = selectElement.value;
          const utterance = new SpeechSynthesisUtterance("张三贺礼五百元整");
          utterance.lang = "zh-CN";

          if (selectedVoiceName) {
            const voices = speechSynthesis.getVoices();
            const selectedVoice = voices.find((voice) => voice.name === selectedVoiceName);
            if (selectedVoice) utterance.voice = selectedVoice;
          }

          speechSynthesis.speak(utterance);
        }

        /**
         * 语音播报礼金信息
         * 使用浏览器 Web Speech API 播报礼金记录
         * @param {string} name - 客人姓名
         * @param {number} amount - 礼金金额
         *
         * 播报规则：
         * - 小于起报金额不播报
         * - 喜事：“姓名 贺礼 金额”
         * - 白事：“姓名，金额”
         */
        speakGift(name, amount) {
          if (!this.isSpeechEnabled || !("speechSynthesis" in window)) return;

          // 起报金额：小于阈值则不播报
          const minAmount = parseFloat(this.currentEvent?.minSpeechAmount || 0) || 0;
          if (typeof amount === "number" && amount < minAmount) return;

          const ttsText = Utils.amountToChinese(amount).replace(/陆/g, "六");
          const textToSpeak = this.currentEvent.theme === "theme-solemn" ? `${name}，${ttsText}` : `${name} 贺礼 ${ttsText}`;

          const utterance = new SpeechSynthesisUtterance(textToSpeak);
          utterance.lang = "zh-CN";

          if (this.currentEvent.voiceName) {
            const voices = speechSynthesis.getVoices();
            const selectedVoice = voices.find((voice) => voice.name === this.currentEvent.voiceName);
            if (selectedVoice) utterance.voice = selectedVoice;
          }

          speechSynthesis.speak(utterance);
        }

        /**
         * 显示事项设置对话框
         */
        async showEditEventInfoModal() {
          this.ui.elements.modal.classList.add("modal-large");

          const [startDate, startTime] = (this.currentEvent.startDateTime || "").split("T");
          const [endDate, endTime] = (this.currentEvent.endDateTime || "").split("T");

          const content = `
      <div class="grid grid-cols-1 md:grid-cols-2 gap-x-6 gap-y-4 text-left">
        <div class="space-y-4">
          <div>
            <label for="edit-event-name-input" class="block text-sm font-medium text-gray-700">事项名称</label>
            <input type="text" id="edit-event-name-input" class="w-full mt-1 p-2 border rounded themed-ring" value="${this.currentEvent.name || ""}">
          </div>

          <div>
            <label for="edit-event-voice" class="block text-sm font-medium text-gray-700">语音播报音色</label>
            <div class="flex items-center gap-2 mt-1">
              <select id="edit-event-voice" class="text-sm flex-grow w-full p-2 border rounded themed-ring">
                <option value="">默认音色</option>
              </select>
              <button type="button" id="preview-edit-voice-btn" class="themed-button-secondary border p-2 rounded whitespace-nowrap text-xs"><i class="ri-volume-up-line"></i> 预览</button>
            </div>
          </div>

          <div>
            <label for="edit-min-speech-amount" class="block text-sm font-medium text-gray-700">语音播报起报金额 (元)</label>
            <input type="number" id="edit-min-speech-amount" min="0" step="1" class="w-full mt-1 p-2 border rounded themed-ring" value="${this.currentEvent.minSpeechAmount || 0}">
            <p class="text-xs text-gray-500 mt-1">只有大于或等于此金额的礼金才会被播报。设置为0则全部播报。</p>
          </div>
          <div>
            <label for="edit-event-recorder" class="block text-sm font-medium text-gray-700">记账人</label>
            <input type="text" id="edit-event-recorder" class="w-full mt-1 p-2 border rounded themed-ring" value="${this.currentEvent.recorder || ""}">
          </div>
          <div>
          <label class="flex items-center cursor-pointer">
            <input type="checkbox" id="edit-hide-privacy" class="w-4 h-4 themed-ring rounded mr-2" ${this.currentEvent.hidePrivacy ? "checked" : ""}>
            <span class="text-sm font-medium text-gray-700">副屏信息脱敏显示</span>
          </label>
          <p class="text-xs text-gray-500 mt-1">开启后，副屏仅显示最新录入记录的完整姓名，其他记录脱敏显示。</p>
        </div>
        </div>

        <div class="space-y-4">
          <div>
            <label class="block text-sm font-medium text-gray-700">事项开始时间</label>
            <div class="flex gap-2 mt-1">
              <input type="date" id="edit-start-date" required class="w-full p-2 border rounded themed-ring" value="${startDate || ""}">
              <input type="time" id="edit-start-time" required class="w-full p-2 border rounded themed-ring" value="${startTime || ""}">
            </div>
          </div>

          <div>
            <label class="block text-sm font-medium text-gray-700">事项结束时间</label>
            <div class="flex gap-2 mt-1">
              <input type="date" id="edit-end-date" required class="w-full p-2 border rounded themed-ring" value="${endDate || ""}">
              <input type="time" id="edit-end-time" required class="w-full p-2 border rounded themed-ring" value="${endTime || ""}">
            </div>
          </div>

          <!-- 仅保留 PDF 引擎选择，因为这属于技术配置而非样式 -->
          <div class="mt-4 pt-4">
              <span class="block text-sm font-medium text-gray-700">PDF渲染方式</span>
              <div class="space-y-2 text-sm text-gray-700 mt-2">
                <label class="flex items-center gap-2 cursor-pointer">
                  <input type="radio" name="edit-pdf-engine" value="browser" class="themed-text-radio themed-ring">
                  <span>浏览器另存为PDF（文件小,不兼容移动端）</span>
                </label>
                <label class="flex items-center gap-2 cursor-pointer">
                  <input type="radio" name="edit-pdf-engine" value="pdf-lib" class="themed-text-radio themed-ring">
                  <span>PDF-LIB.JS引擎（文件稍大,兼容PC/移动端）</span>
                </label>
                <p class="text-xs text-gray-500">浏览器另存为PDF文件较小，不兼容移动端，PDF-LIB.JS生成的pdf文件稍大,支持多平台</p>
              </div>
          </div>
        </div>
      </div>`;

          this.ui.showModal("设置事项", content, [
            {
              text: "礼簿样式设置",
              class: "border px-4 py-2 rounded themed-button-secondary  mr-auto",
              keepOpen: true,
              handler: () => this.showGiftBookStyleModal(),
            },
            { text: "取消", class: "themed-button-secondary border px-4 py-2 rounded" },
            {
              text: "保存",
              class: "themed-button-primary px-4 py-2 rounded",
              keepOpen: true,
              handler: async () => {
                const newName = document.getElementById("edit-event-name-input").value.trim();
                const newVoiceName = document.getElementById("edit-event-voice").value;
                const newMinSpeechAmount = parseFloat(document.getElementById("edit-min-speech-amount").value) || 0;
                const newStartDateTime = `${document.getElementById("edit-start-date").value}T${document.getElementById("edit-start-time").value}`;
                const newEndDateTime = `${document.getElementById("edit-end-date").value}T${document.getElementById("edit-end-time").value}`;
                const newRecorder = document.getElementById("edit-event-recorder").value.trim();
                const hidePrivacy = document.getElementById("edit-hide-privacy").checked;
                const pdfEngineSelection = document.querySelector('input[name="edit-pdf-engine"]:checked')?.value || "browser";

                // 基础验证
                if (!newName) {
                  this.ui.showNotification("事项名称不能为空。", "error");
                  return;
                }
                if (new Date(newStartDateTime) >= new Date(newEndDateTime)) {
                  this.ui.showNotification("开始时间必须早于结束时间。", "error");
                  return;
                }

                // 日期变动验证密码
                const originalStartDateTime = this.currentEvent.startDateTime;
                const originalEndDateTime = this.currentEvent.endDateTime;
                const datesChanged = newStartDateTime !== originalStartDateTime || newEndDateTime !== originalEndDateTime;

                if (datesChanged) {
                  const password = await this.requestAdminPassword("密码验证", "修改事项的起止日期，请输入管理密码以确认。", null, true);
                  if (!password) {
                    this.ui.showNotification("已取消验证，修改未保存。", "info");
                    return;
                  }
                }

                const currentPrintOptions = this.currentEvent.printOptions || {};
                const updatedPrintOptions = {
                  ...currentPrintOptions,
                  pdfEngine: pdfEngineSelection,
                };

                const updatedEvent = {
                  ...this.currentEvent,
                  name: newName,
                  startDateTime: newStartDateTime,
                  endDateTime: newEndDateTime,
                  voiceName: newVoiceName,
                  recorder: newRecorder,
                  minSpeechAmount: newMinSpeechAmount,
                  hidePrivacy: hidePrivacy,
                  printOptions: updatedPrintOptions,
                };

                try {
                  await this.giftRepository.updateEvent(updatedEvent);
                  this.currentEvent = updatedEvent;
                  this.ui.elements.currentEventTitleEl.textContent = newName;

                  // 重新应用样式以防万一
                  await this.applyCustomGiftBookStyle();

                  this.session.save(this.currentEvent, this.currentPassword);

                  this.ui.closeModal();
                  this.ui.showNotification("事项设置更新成功。", "success");
                  this.guestScreenService.syncToGuestScreen();
                } catch (error) {
                  console.error(error);
                  this.ui.showNotification("事项设置保存失败，请重试。", "error");
                }
              },
            },
          ]);

          setTimeout(() => {
            const voiceSelectElement = document.getElementById("edit-event-voice");
            this.populateVoiceList(voiceSelectElement, this.currentEvent.voiceName || "");

            document.getElementById("preview-edit-voice-btn").addEventListener("click", () => {
              this.previewSelectedVoice(voiceSelectElement);
            });

            // 设置 PDF 引擎单选框状态
            const pdfEngineRadio = document.querySelector(`input[name="edit-pdf-engine"][value="${this.currentEvent.printOptions?.pdfEngine || "browser"}"]`);
            if (pdfEngineRadio) {
              pdfEngineRadio.checked = true;
            }
          }, 100);
        }

        /**
         * 删除当前事项
         * 强制要求导出备份并验证管理员密码
         */
        async deleteCurrentEvent() {
          if (!this.currentEvent) return;

          if (this.gifts.length === 0) {
            const password = await this.requestAdminPassword(
              "删除确认",
              `<p>此操作将永久删除事项 \"<strong>${this.currentEvent.name}</strong>\"，无法恢复。</p>
                      <p class=\"mt-4\">请输入管理密码以确认：</p>`,
              null
            );

            if (password === null) return;

            try {
              await this.giftRepository.deleteEvent(this.currentEvent.id);
              this.session.clear();
              this.passwordCache.clear(this.currentEvent.id);
              this.ui.showNotification(`事项 "${this.currentEvent.name}" 已被成功删除。`, "success");

              setTimeout(() => {
                this.currentEvent = null;
                this.currentPassword = null;
                this.gifts = [];
                this.ui.showScreen("setup");
                this.loadEvents();
              }, 500);
            } catch (error) {
              console.error("删除事项时发生错误:", error);
              this.ui.showNotification("删除失败，请重试。", "error");
            }
            return;
          }

          const content = `
                         <div class="text-left space-y-3">
                           <p class="font-semibold text-gray-800">为了确保您的数据安全，删除事项前必须先导出Excel备份。</p>
                           <ol class="list-decimal pl-5 text-sm text-gray-700 space-y-1">
                             <li>点击下方“导出Excel备份”按钮，下载并保存到您的电脑。</li>
                             <li>确认已成功导出后，勾选“我已成功导出Excel备份”。</li>
                             <li>系统会要求输入管理密码后才会执行删除。</li>
                           </ol>
                           <label class="flex items-center mt-4 p-3 bg-gray-50 rounded-lg border border-gray-200 cursor-pointer hover:bg-gray-100">
                             <input id="confirm-exported" type="checkbox" class="w-4 h-4 text-red-600 bg-gray-100 border-gray-300 rounded">
                             <span class="ml-3 text-sm font-medium text-gray-900">我已成功导出Excel备份</span>
                           </label>
                         </div>
                       `;

          let hasExported = false;
          const updateDeleteButtonState = () => {
            const checkbox = document.getElementById("confirm-exported");
            const continueBtn = document.getElementById("btn-continue-delete");
            if (continueBtn && checkbox) {
              const shouldEnable = hasExported && checkbox.checked;
              continueBtn.disabled = !shouldEnable;
              // 添加禁用样式
              if (!shouldEnable) {
                continueBtn.classList.add("opacity-50", "cursor-not-allowed");
              } else {
                continueBtn.classList.remove("opacity-50", "cursor-not-allowed");
              }
            }
          };

          this.ui.showModal("删除事项", content, [
            {
              text: "关闭",
              class: "themed-button-secondary border px-4 py-2 rounded",
              role: "secondary",
            },
            {
              text: "导出Excel备份",
              class: "themed-button-secondary border px-4 py-2 rounded",
              id: "btn-export-excel",
              handler: () => {
                this.exportService.exportToExcel();
                hasExported = true;
                setTimeout(updateDeleteButtonState, 10);
              },
              keepOpen: true,
            },
            {
              text: "已导出，继续删除",
              class: "themed-button-primary px-4 py-2 rounded",
              id: "btn-continue-delete",
              role: "primary",
              handler: async () => {
                const checkbox = document.getElementById("confirm-exported");
                if (!hasExported || !checkbox || !checkbox.checked) {
                  this.ui.showNotification("请先导出 Excel，并勾选确认后再继续。", "error");
                  return;
                }
                const password = await this.requestAdminPassword("删除确认", `此操作将永久删除事项 \"<strong>${this.currentEvent.name}</strong>\" 及其所有礼金记录，且无法恢复。请输入管理密码以确认。`, null, true);
                if (password === null) return;

                try {
                  const eventId = this.currentEvent.id;
                  const allGifts = await this.giftRepository.fetchGiftsByEvent(eventId);
                  for (const gift of allGifts) {
                    await this.giftRepository.deleteGift(gift.id);
                  }
                  await this.giftRepository.deleteEvent(eventId);

                  this.session.clear();
                  this.passwordCache.clear(eventId);
                  this.ui.showNotification(`事项 "${this.currentEvent.name}" 已被成功删除。`, "success");

                  setTimeout(() => {
                    this.currentEvent = null;
                    this.currentPassword = null;
                    this.gifts = [];
                    this.ui.showScreen("setup");
                    this.loadEvents();
                  }, 500);
                } catch (error) {
                  console.error("删除事项时发生错误:", error);
                  this.ui.showNotification("删除失败，请重试。", "error");
                }
              },
              keepOpen: true,
            },
          ]);

          setTimeout(() => {
            const continueBtn = document.getElementById("btn-continue-delete");
            const checkbox = document.getElementById("confirm-exported");
            if (continueBtn) {
              continueBtn.disabled = true;
              continueBtn.classList.add("opacity-50", "cursor-not-allowed");
            }
            if (checkbox) {
              checkbox.addEventListener("change", updateDeleteButtonState);
            }
          }, 10);
        }
        /**
         */
        getItemsPerPage() {
          const val = parseInt(this.currentEvent?.itemsPerPage);
          return val && val > 0 ? val : CONFIG.ITEMS_PER_PAGE;
        }
      }

      class ImageCache {
        static CACHE_NAME = "giftbook-assets-v1";

        /**
         * 获取事项封面的 Cache Key
         */
        static getCoverKey(eventId) {
          return `/event-cover-${eventId}`;
        }

        /**
         * 获取事项背景图的 Cache Key
         */
        static getBackgroundKey(eventId) {
          return `/event-background-${eventId}`;
        }

        /**
         * 通用保存方法 (带大小限制)
         * @param {string} key - 缓存键
         * @param {File|Blob} file - 文件对象
         * @returns {Promise<boolean>} 是否保存成功
         */
        static async save(key, file) {
          if (!("caches" in window)) return false;

          // 确保 CONFIG.MAX_COVER_SIZE 已定义 (默认为 2MB)
          const maxSize = typeof CONFIG !== "undefined" && CONFIG.MAX_COVER_SIZE ? CONFIG.MAX_COVER_SIZE : 2 * 1024 * 1024;

          if (file.size > maxSize) {
            console.warn(`图片过大: ${(file.size / 1024 / 1024).toFixed(2)}MB, 限制: ${(maxSize / 1024 / 1024).toFixed(2)}MB`);
            return false;
          }

          try {
            const cache = await caches.open(this.CACHE_NAME);

            // 构造响应对象存入 Cache
            await cache.put(
              key,
              new Response(file, {
                headers: {
                  "Content-Type": file.type,
                  "Content-Length": file.size,
                },
              })
            );
            return true;
          } catch (e) {
            console.warn("Cache API 保存失败", e);
            return false;
          }
        }

        /**
         * 通用读取方法 (返回 Blob URL)
         * @param {string} key - 缓存键
         */
        static async getUrl(key) {
          if (!("caches" in window)) return null;
          try {
            const cache = await caches.open(this.CACHE_NAME);
            const response = await cache.match(key);
            if (!response) return null;
            const blob = await response.blob();
            return URL.createObjectURL(blob);
          } catch (e) {
            console.error("读取缓存图片失败", e);
            return null;
          }
        }

        /**
         * 通用删除方法
         */
        static async delete(key) {
          if ("caches" in window) {
            const cache = await caches.open(this.CACHE_NAME);
            await cache.delete(key);
          }
        }

        // --- 快捷业务方法 ---

        static async saveBackground(eventId, file) {
          this.deleteBackground(eventId);
          return this.save(this.getBackgroundKey(eventId), file);
        }

        static async getBackgroundUrl(eventId) {
          return this.getUrl(this.getBackgroundKey(eventId));
        }

        static async deleteBackground(eventId) {
          return this.delete(this.getBackgroundKey(eventId));
        }

        static async saveEventCover(eventId, file) {
          this.deleteEventCover(eventId);
          return this.save(this.getCoverKey(eventId), file);
        }

        static async getEventCoverUrl(eventId) {
          return this.getUrl(this.getCoverKey(eventId));
        }

        static async deleteEventCover(eventId) {
          return this.delete(this.getCoverKey(eventId));
        }
      }

      const app = new GiftBookApp();
      app
        .init()
        .then(() => {
          console.log("礼簿系统专业版加载成功！");
          console.log("系统架构: 类化、模块化、现代化");
          console.log("数据加密: AES-256");
          console.log("数据存储: IndexedDB");
        })
        .catch((error) => {
          console.error("? 系统启动失败:", error);
        });

      // 语音列表更新
      if ("speechSynthesis" in window && window.speechSynthesis && speechSynthesis.onvoiceschanged !== undefined) {
        speechSynthesis.onvoiceschanged = () => {
          app.populateVoiceList();
          const editVoiceSelect = document.getElementById("edit-event-voice");
          if (editVoiceSelect) {
            app.populateVoiceList(editVoiceSelect, editVoiceSelect.value);
          }
        };
      }
    </script>
  </body>
</html>
